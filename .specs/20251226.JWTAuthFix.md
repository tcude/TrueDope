# JWT Authentication Fix Specification

**Date**: December 26, 2025
**Status**: IMPLEMENTED
**Issue**: Users experiencing frequent forced re-login on both web app and iOS app
**Related**: [20251215.FixingAuthRefresh.md](20251215.FixingAuthRefresh.md) - Previous fix attempt

## Executive Summary

Despite fixes applied on Dec 15th (60-minute tokens, proactive refresh), users were still experiencing unexpected logouts. Investigation revealed the **iOS app had a critical gap**: it validated token *existence* on startup but not token *validity*, causing the "navigate around, then get kicked to login on first data request" behavior.

### What Dec 15th Fixed
- Access token lifetime: 15 min → 60 min
- Added proactive refresh (5-min buffer) on web frontend
- Rate limiting bumped from 30/min to 300/min

### What Was Still Broken (Now Fixed)
1. ~~**iOS startup doesn't validate tokens**~~ - **FIXED**: Now validates tokens in background on startup
2. ~~**Backend zero clock skew**~~ - **FIXED**: Now allows 60-second clock skew
3. ~~**iOS token expiry can desync**~~ - **FIXED**: Now decodes JWT directly as fallback
4. ~~**Refresh token may have expired**~~ - **FIXED**: Extended from 7 days to 30 days

## Implementation Summary

### Changes Made

| File | Change |
|------|--------|
| `TrueDope/backend/src/TrueDope.Api/Program.cs:87` | `ClockSkew = TimeSpan.FromSeconds(60)` |
| `TrueDope/backend/src/TrueDope.Api/Configuration/JwtSettings.cs:11` | `RefreshTokenExpirationDays = 30` |
| `TrueDope-iOS/TrueDope-iOS/Core/Auth/TokenManager.swift` | Added `getExpiryFromJWT()` method, improved `isTokenExpiredOrExpiringSoon()` to decode JWT as fallback |
| `TrueDope-iOS/TrueDope-iOS/Core/Auth/AuthService.swift` | Added `validateAndRefreshTokensIfNeeded()`, `clearTokens()`, `hasStoredTokens`, `isAccessTokenExpired` |
| `TrueDope-iOS/TrueDope-iOS/App/AppState.swift` | Rewrote `checkAuthState()` with background validation, added `validateTokensInBackground()` and `handleAuthFailure()` |

## Root Cause Analysis

### Primary Issue: iOS App Startup Flow

The iOS app's `checkAuthState()` in [AppState.swift:95-118](TrueDope-iOS/TrueDope-iOS/App/AppState.swift#L95-L118):

```swift
func checkAuthState() async {
    if authService.isAuthenticated {  // ← Only checks hasStoredTokens!
        currentUser = authService.currentUser
        isAuthenticated = true         // ← Shows main UI immediately
        // ... loads preferences
    }
}
```

And `isAuthenticated` in [AuthService.swift:80-82](TrueDope-iOS/TrueDope-iOS/Core/Auth/AuthService.swift#L80-L82):

```swift
var isAuthenticated: Bool {
    tokenManager.hasStoredTokens  // ← Just checks tokens exist, not validity!
}
```

**Result**: App shows authenticated UI even with expired tokens. First API call triggers:
1. `getAccessToken()` → checks expiry → maybe attempts refresh
2. If refresh fails (expired refresh token) → 401 → forced logout
3. User sees login screen after navigating to a data screen

### Why This Wasn't Caught Before

The biometric login flow *does* validate properly ([AuthService.swift:176-225](TrueDope-iOS/TrueDope-iOS/Core/Auth/AuthService.swift#L176-L225)):

```swift
func loginWithBiometric() async throws -> Bool {
    if tokenManager.isAccessTokenExpired {
        try await tokenManager.refreshTokens()  // ← Validates before showing UI!
    }
}
```

But regular app startup bypasses this validation entirely.

### Secondary Issue: Backend Zero Clock Skew

[Program.cs:87](TrueDope/backend/src/TrueDope.Api/Program.cs#L87):
```csharp
ClockSkew = TimeSpan.Zero
```

Any clock drift between client device and server causes immediate token rejection. Mobile devices especially can have clock sync issues.

### Tertiary Issue: Token Expiry Storage (iOS)

Token expiry is stored in UserDefaults ([TokenManager.swift:149](TrueDope-iOS/TrueDope-iOS/Core/Auth/TokenManager.swift#L149)):
```swift
userDefaults.set(expiryDate.timeIntervalSince1970, forKey: Config.tokenExpiryKey)
```

But tokens are in Keychain. If UserDefaults is cleared/corrupted (app reinstall, backup issues), the fallback assumes tokens are valid ([TokenManager.swift:279-284](TrueDope-iOS/TrueDope-iOS/Core/Auth/TokenManager.swift#L279-L284)):
```swift
guard let expiryDate = tokenExpiryDate else {
    // No expiry date means we should try to use the token
    // and let the server decide
    return false  // ← Returns "not expired" even though we don't know!
}
```

## Scenario Walkthrough

### The Exact User Experience You're Seeing (iOS)

1. User logs in → tokens stored (access: 60 min, refresh: 7 days)
2. User closes app, doesn't use it for 8+ days
3. User opens app:
   - `checkAuthState()` runs
   - `hasStoredTokens` = true (tokens exist in Keychain)
   - `isAuthenticated = true` → MainTabView shown
4. User taps "Sessions" tab → `SessionsViewModel.loadSessions()` called
5. APIClient calls `getAccessToken()`:
   - Checks expiry: access token expired (>60 min old)
   - Attempts `refreshTokens()`: refresh token ALSO expired (>7 days)
   - Refresh fails → returns stale token anyway
6. API request made with expired token → 401
7. Reactive refresh triggered → also fails (refresh token expired)
8. `onUnauthorized()` called → `AppState.didLogout()` → LoginView shown

**User sees**: "I could navigate around, but when I tried to load data, it kicked me to login"

### Web App Scenario

Web app is less affected because:
1. Proactive refresh runs on every API call (5 min buffer)
2. `localStorage` doesn't have the same backup/restore issues as iOS UserDefaults

But can still fail if:
- User leaves tab open for >7 days without any API calls
- Multiple tabs cause refresh race conditions

## Remediation Plan

### Phase 0: Quick Win (10 minutes)

#### Add Clock Skew Tolerance
**File**: [TrueDope/backend/src/TrueDope.Api/Program.cs:87](TrueDope/backend/src/TrueDope.Api/Program.cs#L87)

```csharp
// Change from:
ClockSkew = TimeSpan.Zero
// To:
ClockSkew = TimeSpan.FromSeconds(60)
```

**Impact**: Prevents edge cases where device clock is slightly off.

---

### Phase 1: iOS Token Validation on Startup (Primary Fix)

#### Option A: Background Validation (Recommended)
Show UI immediately, validate in background, gracefully handle failure.

**File**: [TrueDope-iOS/TrueDope-iOS/App/AppState.swift](TrueDope-iOS/TrueDope-iOS/App/AppState.swift)

Replace `checkAuthState()` with:

```swift
func checkAuthState() async {
    isLoading = true

    guard authService.hasStoredTokens else {
        isAuthenticated = false
        isLoading = false
        return
    }

    // Show UI immediately with cached state
    if let savedUser = loadCachedUserInfo() {
        currentUser = savedUser
        currentUserId = savedUser.userId
        isAuthenticated = true
        canUseBiometric = authService.isBiometricEnabled && authService.isBiometricAvailable
    }

    isLoading = false

    // Validate tokens in background
    Task {
        do {
            // Force a token validity check
            if authService.tokenManager.isAccessTokenExpired {
                try await authService.tokenManager.refreshTokens()
            }
            // Optional: verify with server by fetching profile
            // This confirms the token actually works
            _ = try await userService.getCurrentUser()
        } catch {
            // Token invalid, force re-login
            Log.info("Background token validation failed, logging out")
            await MainActor.run {
                handleAuthFailure()
            }
        }
    }
}

private func handleAuthFailure() {
    authService.clearTokens()
    currentUser = nil
    currentUserId = nil
    isAuthenticated = false
    canUseBiometric = false
    // User will see login screen appear
}
```

**Pros**: Fast startup, seamless if tokens valid, graceful degradation
**Cons**: Brief moment where stale data could show if tokens invalid

#### Option B: Blocking Validation
Validate tokens before showing authenticated UI.

```swift
func checkAuthState() async {
    isLoading = true

    guard authService.hasStoredTokens else {
        isAuthenticated = false
        isLoading = false
        return
    }

    // Validate tokens before showing UI
    do {
        if authService.tokenManager.isAccessTokenExpired {
            try await authService.tokenManager.refreshTokens()
        }

        // Tokens are valid, show authenticated UI
        currentUser = authService.currentUser
        currentUserId = currentUser?.userId
        isAuthenticated = true
        canUseBiometric = authService.isBiometricEnabled && authService.isBiometricAvailable
        await loadPreferences()
    } catch {
        // Token validation failed
        Log.info("Token validation failed on startup")
        authService.clearTokens()
        isAuthenticated = false
    }

    isLoading = false
}
```

**Pros**: Never shows authenticated UI with invalid tokens
**Cons**: Slower startup (requires network), bad offline experience

---

### Phase 2: Improve Token Expiry Handling (iOS)

#### Decode JWT for Expiry Instead of Trusting UserDefaults
**File**: [TrueDope-iOS/TrueDope-iOS/Core/Auth/TokenManager.swift](TrueDope-iOS/TrueDope-iOS/Core/Auth/TokenManager.swift)

Add JWT decoding to extract `exp` claim directly:

```swift
private func getExpiryFromJWT(_ token: String) -> Date? {
    let parts = token.components(separatedBy: ".")
    guard parts.count == 3 else { return nil }

    // JWT base64 needs padding
    var base64 = parts[1]
        .replacingOccurrences(of: "-", with: "+")
        .replacingOccurrences(of: "_", with: "/")

    while base64.count % 4 != 0 {
        base64.append("=")
    }

    guard let payloadData = Data(base64Encoded: base64),
          let payload = try? JSONSerialization.jsonObject(with: payloadData) as? [String: Any],
          let exp = payload["exp"] as? TimeInterval else {
        return nil
    }

    return Date(timeIntervalSince1970: exp)
}
```

Then modify `isTokenExpiredOrExpiringSoon()`:

```swift
private func isTokenExpiredOrExpiringSoon() -> Bool {
    // First try UserDefaults (fast)
    if let expiryDate = tokenExpiryDate {
        let bufferDate = Date().addingTimeInterval(expiryBuffer)
        return expiryDate <= bufferDate
    }

    // Fallback: decode JWT directly
    if let token = cachedAccessToken,
       let jwtExpiry = getExpiryFromJWT(token) {
        let bufferDate = Date().addingTimeInterval(expiryBuffer)
        return jwtExpiry <= bufferDate
    }

    // No way to determine expiry - assume expired to be safe
    return true  // Changed from false!
}
```

---

### Phase 3: Extend Session Duration

Based on your preference for more seamless auth, consider extending refresh token lifetime.

**File**: [TrueDope/backend/src/TrueDope.Api/Configuration/JwtSettings.cs](TrueDope/backend/src/TrueDope.Api/Configuration/JwtSettings.cs)

```csharp
public int RefreshTokenExpirationDays { get; set; } = 30;  // Was 7
```

**Trade-off**: Longer sessions vs. security (stolen refresh token valid longer)

For a shooting data app (not financial/health), 30 days is reasonable.

---

### Phase 4: Web App Improvements (Lower Priority)

#### Add Error Handling to JWT Decode
**File**: [TrueDope/frontend/src/services/api.ts](TrueDope/frontend/src/services/api.ts)

The current `getTokenExpiration()` could crash on malformed tokens:

```typescript
function getTokenExpiration(token: string): number | null {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    const payload = JSON.parse(atob(parts[1]));
    return payload.exp ? payload.exp * 1000 : null;
  } catch {
    console.warn('[Auth] Failed to decode JWT');
    return null;
  }
}
```

## Implementation Priority

| Priority | Task | Effort | Impact |
|----------|------|--------|--------|
| **P0** | Backend clock skew tolerance | 10 min | Prevents edge case failures |
| **P0** | iOS startup token validation | 2 hrs | **Fixes primary symptom** |
| **P1** | iOS JWT decode for expiry | 1 hr | Eliminates storage sync issues |
| **P1** | Extend refresh token to 30 days | 10 min | Reduces re-login frequency |
| **P2** | Web JWT decode error handling | 30 min | Prevents crashes |

## Testing Plan

### After Implementation

1. **iOS Cold Start Test (Primary)**:
   - Log in on iOS
   - Kill app completely
   - Wait >60 minutes (or manually expire token in Keychain for testing)
   - Open app
   - **Expected**: Either seamless refresh OR immediate login prompt (not navigate-then-logout)

2. **iOS 7+ Day Test**:
   - Log in on iOS
   - Don't use app for 8+ days (or manually expire refresh token)
   - Open app
   - **Expected**: Immediate login prompt (not navigate-then-logout)

3. **Web Extended Session Test**:
   - Log in on web
   - Leave tab open for extended period
   - Perform actions
   - **Expected**: Seamless token refresh, no logout

### Quick Verification

After implementing clock skew fix, you can test by:
1. Setting device clock 30 seconds ahead
2. Making API request
3. Should still work (currently would fail)

## Summary

The core issue is that **iOS doesn't validate token validity on startup** - it only checks if tokens exist. Combined with:
- 7-day refresh token expiration
- Zero clock skew tolerance
- Token expiry stored separately from tokens

...this creates the exact symptom you're seeing: "app opens fine, I can navigate, but first data request kicks me to login."

**Minimum fix**: iOS startup validation + clock skew tolerance.
**Full fix**: Add JWT decode fallback + extend refresh token lifetime.

The goal is: **mobile users should never have to re-login unless they explicitly log out or don't use the app for 30+ days**.
