# TrueDope Group Measurement Feature - Specification Manifest

**Document Version:** 1.0
**Date:** 2025-12-27
**Status:** Draft

---

## Table of Contents
1. [Executive Summary](#executive-summary)
2. [Architecture Decisions](#architecture-decisions)
3. [TrueDope Target System](#truedope-target-system)
4. [Data Model Extensions](#data-model-extensions)
5. [iOS Implementation](#ios-implementation)
6. [Backend Implementation](#backend-implementation)
7. [Measurement Algorithms](#measurement-algorithms)
8. [Implementation Phases](#implementation-phases)
9. [Technical Risks & Mitigations](#technical-risks--mitigations)

---

## Executive Summary

### Goal
Enable TrueDope iOS users to photograph targets and automatically (or semi-automatically) calculate group size metrics. By providing our own printable targets with fiducial markers, we eliminate manual calibration and enable perspective correction.

### Key Innovation
TrueDope-branded printable targets with ArUco/fiducial markers enable:
- **Automatic calibration** - no "mark 1 inch" step
- **Perspective correction** - shoot photo from any reasonable angle
- **Consistent measurements** - known grid spacing validates detection
- **Fallback support** - manual mode for any target

### Integration with Existing System
The `GroupEntry` entity already exists with support for:
- Group size (MOA) and mean radius (MOA)
- Image attachments via MinIO
- Session/ammunition relationships

This feature extends GroupEntry by:
1. Adding computed measurement data (hole positions, extended metrics)
2. Enabling camera-based data entry as an alternative to manual input
3. Storing both original and annotated images

---

## Architecture Decisions

### Question 1: How does this fit with the existing data model?

**Recommendation:** Extend `GroupEntry` with a new related entity `GroupMeasurement`

The current `GroupEntry` already stores:
- `GroupSizeMoa` (extreme spread in MOA)
- `MeanRadiusMoa`
- `Images` collection
- `Distance`, `NumberOfShots`

The new `GroupMeasurement` entity will store:
- Hole coordinate data (for recalculation/visualization)
- Extended metrics (CEP, H/V spread, standard deviations)
- POI offset from POA
- Bullet diameter used
- Original and annotated image references

**Relationship:** `GroupEntry` 1:1 (optional) `GroupMeasurement`

A GroupEntry can exist without measurement data (manual entry), and measurement data is always tied to a specific GroupEntry.

```
GroupEntry (existing)
├── id, groupNumber, distance, numberOfShots
├── groupSizeMoa, meanRadiusMoa (basic metrics - can be populated from measurement OR manual)
├── ammunitionId, ammoLotId, notes
├── images[] (can include target photos)
└── groupMeasurement? (NEW - optional 1:1)
    ├── holePositions[] (x,y coordinates in inches from POA)
    ├── bulletDiameter (inches)
    ├── horizontalSpread, verticalSpread (inches)
    ├── radialStdDev, horizontalStdDev, verticalStdDev
    ├── cep50 (circular error probable - 50%)
    ├── poiOffsetX, poiOffsetY (inches from POA)
    ├── calibrationMethod (enum: fiducial, manual, qrCode)
    ├── originalImageId, annotatedImageId
    └── measurementConfidence (0-1, based on detection quality)
```

### Question 2: Current image handling pattern?

**Current iOS Pattern:**
- `ImageService` handles compression (0.8 JPEG quality), resizing (max 2048px)
- Upload via Alamofire multipart form data
- Backend stores in MinIO with auto-generated thumbnails
- URLs returned for display via SDWebImage

**For Group Measurement:**
- Use existing `ImageService.uploadGroupImage(groupId:image:)`
- Store two images: original capture + annotated overlay
- Consider storing measurement metadata as image caption JSON (lightweight approach)

### Question 3: Measurement UI location?

**Recommendation:** Hybrid approach

1. **Entry point within SessionDetailView** - "Measure Group" button on GroupEntry cards
2. **Standalone accessible via quick action** - For rapid capture when user just wants to measure without full session context
3. **New group creation flow** - Option to "Add Group with Photo" that captures image first

The measurement flow should be presented as a **sheet/modal** that:
- Captures/selects image
- Performs detection and measurement
- Returns to create/update the GroupEntry

### Question 4: Camera/photo picker flow patterns?

**Current iOS Patterns (from SessionDetailView):**
```swift
@State private var showingImageSourcePicker = false
@State private var selectedImageSource: UIImagePickerController.SourceType?
@State private var selectedImage: UIImage?

.confirmationDialog("Select Image Source", isPresented: $showingImageSourcePicker) {
    Button("Camera") { selectedImageSource = .camera }
    Button("Photo Library") { selectedImageSource = .photoLibrary }
}
```

**For Group Measurement:**
Follow same pattern but add post-capture processing step before saving.

---

## TrueDope Target System

### Target Design Specifications

#### Fiducial Marker Requirements
- **Type:** ArUco markers (6x6_250 dictionary recommended for OpenCV compatibility)
- **Placement:** Four corners, consistently positioned across all variants
- **Size:** 0.75" x 0.75" (provides good detection at various distances)
- **IDs:** Use unique IDs per corner for orientation detection
  - Top-Left: ID 0
  - Top-Right: ID 1
  - Bottom-Right: ID 2
  - Bottom-Left: ID 3

#### Grid System
- **Primary grid:** 0.5" squares (precision rifle variant)
- **Grid lines:** Light gray, 0.5pt weight (visible but not distracting)
- **Major grid lines:** Every 1" with slightly heavier weight
- **Grid origin:** Center of POA box

#### Print Specifications
- **Page size:** Letter (8.5" x 11")
- **Safe area:** 0.5" margins all sides for printer compatibility
- **Marker positions (from corners):**
  - Top-Left marker: (0.75", 0.75") from page corner
  - Top-Right marker: (7.0", 0.75") from page corner
  - Bottom corners: mirror of top
- **Known distance between marker centers:**
  - Horizontal: 6.25" (7.0" - 0.75")
  - Vertical: 9.0" (9.75" - 0.75")

#### QR Code (Optional Enhancement)
- **Location:** Bottom center, below lowest POA box
- **Size:** 1" x 1"
- **Encoded data (JSON):**
```json
{
  "v": 1,
  "t": "precision",
  "g": 0.5,
  "d": "2025-12-27",
  "s": "abc123"
}
```
Where:
- `v`: Target format version
- `t`: Target type (precision, pistol, loaddev)
- `g`: Grid spacing in inches
- `d`: Print date (optional)
- `s`: Session UUID (optional, for linking)

### Target Variants

#### 1. Precision Rifle Target
- **Grid:** 0.5" squares
- **POA boxes:** 3 boxes (1.5" squares) - top, middle, bottom of page
- **Use case:** 100+ yard precision rifle groups

#### 2. Pistol/Rimfire Target
- **Grid:** 1" squares
- **POA boxes:** 4 boxes (2" squares) in 2x2 grid
- **Use case:** Closer range, larger groups

#### 3. Load Development Target
- **Grid:** 0.5" squares
- **POA boxes:** 5 small boxes (1" squares) in vertical column
- **Labels:** Space for writing load data next to each box
- **Use case:** Testing multiple loads in one session

### Target Generation Strategy

**Recommendation:** Generate PDFs dynamically on the backend

**Pros:**
- Can embed session UUID for automatic linking
- Can customize with user's name/date
- Easy to version and update target designs

**Backend Endpoint:**
```
GET /api/targets/generate?type=precision&sessionId=123
Returns: PDF binary with Content-Disposition header
```

**Bundled Fallback:**
Include static PDFs in iOS app bundle for offline use.

**Print Instructions:**
Every PDF should include:
- "PRINT AT 100% SCALE - DO NOT FIT TO PAGE"
- 1" verification ruler graphic at bottom
- TrueDope branding/logo

---

## Data Model Extensions

### Backend: New Entity - GroupMeasurement

```csharp
// TrueDope.Api/Data/Entities/GroupMeasurement.cs

public class GroupMeasurement
{
    public int Id { get; set; }

    // Parent relationship (1:1 with GroupEntry)
    [Required]
    public int GroupEntryId { get; set; }
    public GroupEntry GroupEntry { get; set; } = null!;

    // Hole position data (stored as JSON)
    // Each position is {x, y} in inches relative to POA
    [Required]
    [Column(TypeName = "jsonb")]
    public string HolePositionsJson { get; set; } = "[]";

    // Bullet diameter used for calculations (inches)
    [Required]
    [Column(TypeName = "decimal(5,3)")]
    [Range(0.1, 1.0)]
    public decimal BulletDiameter { get; set; }

    // Extended metrics (all in inches unless noted)
    [Column(TypeName = "decimal(6,3)")]
    public decimal? HorizontalSpread { get; set; }

    [Column(TypeName = "decimal(6,3)")]
    public decimal? VerticalSpread { get; set; }

    [Column(TypeName = "decimal(6,4)")]
    public decimal? RadialStdDev { get; set; }

    [Column(TypeName = "decimal(6,4)")]
    public decimal? HorizontalStdDev { get; set; }

    [Column(TypeName = "decimal(6,4)")]
    public decimal? VerticalStdDev { get; set; }

    [Column(TypeName = "decimal(6,3)")]
    public decimal? Cep50 { get; set; }  // 50% circular error probable

    // POI offset from POA (negative = left/low, positive = right/high)
    [Column(TypeName = "decimal(6,3)")]
    public decimal? PoiOffsetX { get; set; }

    [Column(TypeName = "decimal(6,3)")]
    public decimal? PoiOffsetY { get; set; }

    // Calibration metadata
    [Required]
    public CalibrationMethod CalibrationMethod { get; set; }

    [Column(TypeName = "decimal(3,2)")]
    [Range(0, 1)]
    public decimal? MeasurementConfidence { get; set; }

    // Image references (nullable - images stored in Images table)
    public int? OriginalImageId { get; set; }
    public Image? OriginalImage { get; set; }

    public int? AnnotatedImageId { get; set; }
    public Image? AnnotatedImage { get; set; }

    // Audit
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
}

public enum CalibrationMethod
{
    Fiducial = 0,    // TrueDope target with ArUco markers
    QrCode = 1,      // QR code provided calibration data
    Manual = 2,      // User set reference distance
    GridDetect = 3   // Grid pattern auto-detected
}
```

### Backend: DTO Extensions

```csharp
// TrueDope.Api/DTOs/Sessions/GroupMeasurementDtos.cs

public class HolePosition
{
    public decimal X { get; set; }  // inches from POA, positive = right
    public decimal Y { get; set; }  // inches from POA, positive = up
}

public class GroupMeasurementDto
{
    public int Id { get; set; }
    public int GroupEntryId { get; set; }
    public List<HolePosition> HolePositions { get; set; } = new();
    public decimal BulletDiameter { get; set; }
    public decimal? HorizontalSpread { get; set; }
    public decimal? VerticalSpread { get; set; }
    public decimal? RadialStdDev { get; set; }
    public decimal? HorizontalStdDev { get; set; }
    public decimal? VerticalStdDev { get; set; }
    public decimal? Cep50 { get; set; }
    public decimal? PoiOffsetX { get; set; }
    public decimal? PoiOffsetY { get; set; }
    public string CalibrationMethod { get; set; } = string.Empty;
    public decimal? MeasurementConfidence { get; set; }
    public ImageDto? OriginalImage { get; set; }
    public ImageDto? AnnotatedImage { get; set; }
}

public class CreateGroupMeasurementDto
{
    [Required]
    public List<HolePosition> HolePositions { get; set; } = new();

    [Required]
    [Range(0.1, 1.0)]
    public decimal BulletDiameter { get; set; }

    [Required]
    public string CalibrationMethod { get; set; } = "manual";

    [Range(0, 1)]
    public decimal? MeasurementConfidence { get; set; }

    // Distance for MOA conversion
    [Required]
    [Range(25, 2500)]
    public int DistanceYards { get; set; }
}
```

### iOS: Model Extensions

```swift
// TrueDope-iOS/Models/GroupMeasurement.swift

import Foundation

// MARK: - Hole Position

struct HolePosition: Codable, Hashable {
    let x: Decimal  // inches from POA, positive = right
    let y: Decimal  // inches from POA, positive = up

    var point: CGPoint {
        CGPoint(
            x: CGFloat(truncating: x as NSNumber),
            y: CGFloat(truncating: y as NSNumber)
        )
    }
}

// MARK: - Calibration Method

enum CalibrationMethod: String, Codable, CaseIterable {
    case fiducial = "fiducial"
    case qrCode = "qrCode"
    case manual = "manual"
    case gridDetect = "gridDetect"

    var displayName: String {
        switch self {
        case .fiducial: return "TrueDope Target"
        case .qrCode: return "QR Code"
        case .manual: return "Manual Calibration"
        case .gridDetect: return "Grid Detection"
        }
    }
}

// MARK: - Group Measurement DTO

struct GroupMeasurement: Codable, Identifiable {
    let id: Int
    let groupEntryId: Int
    let holePositions: [HolePosition]
    let bulletDiameter: Decimal

    // Extended metrics (inches)
    let horizontalSpread: Decimal?
    let verticalSpread: Decimal?
    let radialStdDev: Decimal?
    let horizontalStdDev: Decimal?
    let verticalStdDev: Decimal?
    let cep50: Decimal?

    // POI offset
    let poiOffsetX: Decimal?
    let poiOffsetY: Decimal?

    // Calibration
    let calibrationMethod: CalibrationMethod
    let measurementConfidence: Decimal?

    // Images
    let originalImage: GroupImage?
    let annotatedImage: GroupImage?

    // MARK: - Computed Properties

    var shotCount: Int {
        holePositions.count
    }

    /// Group centroid
    var centroid: HolePosition {
        guard !holePositions.isEmpty else {
            return HolePosition(x: 0, y: 0)
        }
        let sumX = holePositions.reduce(Decimal.zero) { $0 + $1.x }
        let sumY = holePositions.reduce(Decimal.zero) { $0 + $1.y }
        let count = Decimal(holePositions.count)
        return HolePosition(x: sumX / count, y: sumY / count)
    }

    /// Formatted horizontal spread
    var formattedHorizontalSpread: String? {
        guard let spread = horizontalSpread else { return nil }
        return String(format: "%.3f\"", NSDecimalNumber(decimal: spread).doubleValue)
    }

    /// Formatted vertical spread
    var formattedVerticalSpread: String? {
        guard let spread = verticalSpread else { return nil }
        return String(format: "%.3f\"", NSDecimalNumber(decimal: spread).doubleValue)
    }

    /// Formatted CEP
    var formattedCep50: String? {
        guard let cep = cep50 else { return nil }
        return String(format: "%.3f\"", NSDecimalNumber(decimal: cep).doubleValue)
    }

    /// POI offset description
    var poiOffsetDescription: String? {
        guard let x = poiOffsetX, let y = poiOffsetY else { return nil }
        let xDir = x >= 0 ? "R" : "L"
        let yDir = y >= 0 ? "H" : "L"
        return String(format: "%.2f\" %@, %.2f\" %@",
                      abs(NSDecimalNumber(decimal: x).doubleValue), xDir,
                      abs(NSDecimalNumber(decimal: y).doubleValue), yDir)
    }

    /// Confidence level description
    var confidenceDescription: String {
        guard let conf = measurementConfidence else { return "Unknown" }
        let value = NSDecimalNumber(decimal: conf).doubleValue
        switch value {
        case 0.9...: return "High"
        case 0.7..<0.9: return "Good"
        case 0.5..<0.7: return "Fair"
        default: return "Low"
        }
    }
}

// MARK: - Create Request

struct CreateGroupMeasurementRequest: Codable {
    let holePositions: [HolePosition]
    let bulletDiameter: Decimal
    let calibrationMethod: CalibrationMethod
    let measurementConfidence: Decimal?
    let distanceYards: Int

    init(
        holePositions: [HolePosition],
        bulletDiameter: Decimal,
        calibrationMethod: CalibrationMethod = .manual,
        measurementConfidence: Decimal? = nil,
        distanceYards: Int
    ) {
        self.holePositions = holePositions
        self.bulletDiameter = bulletDiameter
        self.calibrationMethod = calibrationMethod
        self.measurementConfidence = measurementConfidence
        self.distanceYards = distanceYards
    }
}
```

### Update GroupEntry to include optional measurement

```swift
// Update GroupEntry.swift

struct GroupEntry: Codable, Identifiable {
    // ... existing properties ...

    // NEW: Optional linked measurement data
    let measurement: GroupMeasurement?

    /// Has detailed measurement data
    var hasMeasurementData: Bool {
        measurement != nil
    }
}
```

---

## iOS Implementation

### Framework Dependencies

```swift
// New SPM dependencies needed:

// For ArUco marker detection (if using OpenCV)
// Option A: opencv2.xcframework via SPM
// Option B: Use Vision framework with custom marker detection

// Recommended: Start with Vision framework + Core Image
// Add OpenCV only if Vision proves insufficient for ArUco
```

### Service Layer: GroupMeasurementService

```swift
// TrueDope-iOS/Core/Services/GroupMeasurementService.swift

import Foundation
import Vision
import CoreImage
import UIKit

protocol GroupMeasurementServiceProtocol {
    // Target detection
    func detectTrueDopeTarget(in image: UIImage) async throws -> TargetDetectionResult

    // Hole detection
    func detectHoles(in image: UIImage, calibration: CalibrationData) async throws -> [DetectedHole]

    // Measurement calculation
    func calculateMetrics(
        holes: [HolePosition],
        bulletDiameter: Decimal,
        distanceYards: Int
    ) -> GroupMetrics

    // Image annotation
    func createAnnotatedImage(
        original: UIImage,
        holes: [DetectedHole],
        calibration: CalibrationData,
        metrics: GroupMetrics
    ) -> UIImage

    // API operations
    func saveMeasurement(
        groupId: Int,
        request: CreateGroupMeasurementRequest,
        originalImage: UIImage,
        annotatedImage: UIImage
    ) async throws -> GroupMeasurement
}

// MARK: - Detection Results

struct TargetDetectionResult {
    let isDetected: Bool
    let calibration: CalibrationData?
    let confidence: Double
    let perspectiveCorrectedImage: UIImage?
    let qrData: TargetQRData?
}

struct CalibrationData {
    let pixelsPerInch: Double
    let transform: CGAffineTransform?  // For perspective correction
    let origin: CGPoint  // POA location in image coordinates
    let rotationAngle: Double
}

struct DetectedHole {
    var center: CGPoint          // Image coordinates
    let radius: CGFloat          // Detected radius in pixels
    let confidence: Double       // 0-1 detection confidence
    var position: HolePosition?  // Calculated real-world position (after calibration)
}

struct TargetQRData: Codable {
    let version: Int
    let targetType: String
    let gridSpacing: Double
    let printDate: String?
    let sessionId: String?
}

struct GroupMetrics {
    let extremeSpread: Decimal      // Group size (max hole-to-hole + bullet diameter)
    let meanRadius: Decimal         // Average distance from centroid
    let horizontalSpread: Decimal
    let verticalSpread: Decimal
    let radialStdDev: Decimal
    let horizontalStdDev: Decimal
    let verticalStdDev: Decimal
    let cep50: Decimal
    let centroid: HolePosition
    let poiOffset: HolePosition     // From POA (0,0)

    // MOA conversions
    func extremeSpreadMoa(atYards distance: Int) -> Decimal {
        inchesToMoa(extremeSpread, atYards: distance)
    }

    func meanRadiusMoa(atYards distance: Int) -> Decimal {
        inchesToMoa(meanRadius, atYards: distance)
    }

    private func inchesToMoa(_ inches: Decimal, atYards distance: Int) -> Decimal {
        // MOA = (inches / distance) * (100 / 1.047)
        let distDecimal = Decimal(distance)
        return (inches / distDecimal) * (100 / Decimal(string: "1.047")!)
    }
}
```

### View Layer: MeasurementFlow

```swift
// TrueDope-iOS/Features/GroupMeasurement/Views/GroupMeasurementView.swift

import SwiftUI
import PhotosUI

struct GroupMeasurementView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel: GroupMeasurementViewModel

    // Bindings for result
    let sessionId: Int
    let existingGroupId: Int?  // nil if creating new group
    let onComplete: (GroupEntry) -> Void

    @State private var currentStep: MeasurementStep = .capture

    enum MeasurementStep {
        case capture           // Camera/photo library selection
        case detection         // Analyzing image for target/holes
        case adjustment        // User confirms/adjusts detected holes
        case metadata          // Distance, ammo, notes
        case review            // Final review before save
    }

    var body: some View {
        NavigationStack {
            Group {
                switch currentStep {
                case .capture:
                    CaptureStepView(
                        selectedImage: $viewModel.capturedImage,
                        onImageSelected: {
                            currentStep = .detection
                            Task { await viewModel.analyzeImage() }
                        }
                    )
                case .detection:
                    DetectionProgressView(
                        progress: viewModel.detectionProgress,
                        status: viewModel.detectionStatus
                    )
                    .task {
                        if viewModel.detectionComplete {
                            currentStep = .adjustment
                        }
                    }
                case .adjustment:
                    HoleAdjustmentView(
                        image: viewModel.displayImage,
                        detectedHoles: $viewModel.detectedHoles,
                        poaLocation: $viewModel.poaLocation,
                        calibration: viewModel.calibration,
                        onConfirm: { currentStep = .metadata }
                    )
                case .metadata:
                    MetadataEntryView(
                        distance: $viewModel.distance,
                        bulletDiameter: $viewModel.bulletDiameter,
                        ammunition: $viewModel.selectedAmmunition,
                        notes: $viewModel.notes,
                        onConfirm: {
                            viewModel.calculateMetrics()
                            currentStep = .review
                        }
                    )
                case .review:
                    MeasurementReviewView(
                        image: viewModel.annotatedImage,
                        metrics: viewModel.calculatedMetrics,
                        holes: viewModel.confirmedHoles,
                        onSave: {
                            Task {
                                if let result = await viewModel.save(
                                    sessionId: sessionId,
                                    existingGroupId: existingGroupId
                                ) {
                                    onComplete(result)
                                    dismiss()
                                }
                            }
                        }
                    )
                }
            }
            .navigationTitle(navigationTitle)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
                if currentStep != .capture && currentStep != .detection {
                    ToolbarItem(placement: .navigationBarLeading) {
                        Button("Back") { goBack() }
                    }
                }
            }
            .alert("Error", isPresented: $viewModel.showError) {
                Button("OK") { }
            } message: {
                Text(viewModel.errorMessage)
            }
        }
    }

    private var navigationTitle: String {
        switch currentStep {
        case .capture: return "Capture Target"
        case .detection: return "Analyzing..."
        case .adjustment: return "Mark Holes"
        case .metadata: return "Group Details"
        case .review: return "Review"
        }
    }

    private func goBack() {
        switch currentStep {
        case .capture: break
        case .detection: currentStep = .capture
        case .adjustment: currentStep = .capture
        case .metadata: currentStep = .adjustment
        case .review: currentStep = .metadata
        }
    }
}
```

### Hole Adjustment View (Core Interaction)

```swift
// TrueDope-iOS/Features/GroupMeasurement/Views/HoleAdjustmentView.swift

import SwiftUI

struct HoleAdjustmentView: View {
    let image: UIImage
    @Binding var detectedHoles: [DetectedHole]
    @Binding var poaLocation: CGPoint
    let calibration: CalibrationData?
    let onConfirm: () -> Void

    @State private var selectedHoleIndex: Int?
    @State private var showingManualCalibration = false
    @State private var manualReferencePoints: (CGPoint, CGPoint)?

    var body: some View {
        VStack(spacing: 0) {
            // Instructions banner
            InstructionBanner(
                text: calibration != nil
                    ? "Tap to add holes, drag to adjust. Tap POA box to set aim point."
                    : "No target detected. Set reference distance first."
            )

            // Interactive image view
            GeometryReader { geometry in
                ZoomableImageView(image: image) { imageView in
                    // Overlay for holes
                    ForEach(Array(detectedHoles.enumerated()), id: \.offset) { index, hole in
                        HoleMarker(
                            position: hole.center,
                            isSelected: selectedHoleIndex == index,
                            confidence: hole.confidence
                        )
                        .onTapGesture { selectedHoleIndex = index }
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    detectedHoles[index].center = value.location
                                }
                        )
                    }

                    // POA marker
                    POAMarker(position: poaLocation)
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    poaLocation = value.location
                                }
                        )

                    // Tap to add new hole
                    Color.clear
                        .contentShape(Rectangle())
                        .onTapGesture { location in
                            let newHole = DetectedHole(
                                center: location,
                                radius: 10, // Default
                                confidence: 1.0, // Manual = certain
                                position: nil
                            )
                            detectedHoles.append(newHole)
                        }
                }
            }

            // Bottom toolbar
            HStack {
                // Hole count
                Text("\(detectedHoles.count) holes")
                    .font(.subheadline)

                Spacer()

                // Delete selected
                if selectedHoleIndex != nil {
                    Button(role: .destructive) {
                        if let index = selectedHoleIndex {
                            detectedHoles.remove(at: index)
                            selectedHoleIndex = nil
                        }
                    } label: {
                        Label("Remove", systemImage: "trash")
                    }
                }

                Spacer()

                // Manual calibration (if no auto-calibration)
                if calibration == nil {
                    Button {
                        showingManualCalibration = true
                    } label: {
                        Label("Calibrate", systemImage: "ruler")
                    }
                }

                Spacer()

                // Confirm
                Button(action: onConfirm) {
                    Text("Confirm")
                        .fontWeight(.semibold)
                }
                .disabled(detectedHoles.count < 2)
            }
            .padding()
            .background(Color(.systemBackground))
        }
        .sheet(isPresented: $showingManualCalibration) {
            ManualCalibrationSheet(
                image: image,
                referencePoints: $manualReferencePoints,
                onComplete: { pixelsPerInch in
                    // Update calibration with manual data
                }
            )
        }
    }
}

struct HoleMarker: View {
    let position: CGPoint
    let isSelected: Bool
    let confidence: Double

    var body: some View {
        Circle()
            .stroke(markerColor, lineWidth: isSelected ? 3 : 2)
            .frame(width: 30, height: 30)
            .background(
                Circle()
                    .fill(markerColor.opacity(0.2))
            )
            .position(position)
    }

    private var markerColor: Color {
        if isSelected { return .blue }
        switch confidence {
        case 0.8...: return .green
        case 0.5..<0.8: return .yellow
        default: return .orange
        }
    }
}

struct POAMarker: View {
    let position: CGPoint

    var body: some View {
        ZStack {
            // Crosshairs
            Rectangle()
                .fill(Color.red)
                .frame(width: 40, height: 2)
            Rectangle()
                .fill(Color.red)
                .frame(width: 2, height: 40)
            // Center dot
            Circle()
                .fill(Color.red)
                .frame(width: 8, height: 8)
        }
        .position(position)
    }
}
```

---

## Backend Implementation

### New API Endpoints

```csharp
// TrueDope.Api/Controllers/GroupMeasurementsController.cs

[ApiController]
[Route("api/groups/{groupId:int}/measurement")]
[Authorize]
public class GroupMeasurementsController : ControllerBase
{
    // GET /api/groups/{groupId}/measurement
    // Returns measurement data if exists
    [HttpGet]
    public async Task<ActionResult<ApiResponse<GroupMeasurementDto>>> GetMeasurement(int groupId)

    // POST /api/groups/{groupId}/measurement
    // Creates measurement and updates GroupEntry with calculated MOA values
    [HttpPost]
    public async Task<ActionResult<ApiResponse<GroupMeasurementDto>>> CreateMeasurement(
        int groupId,
        [FromBody] CreateGroupMeasurementDto request)

    // PUT /api/groups/{groupId}/measurement
    // Updates measurement (recalculates metrics)
    [HttpPut]
    public async Task<ActionResult<ApiResponse<GroupMeasurementDto>>> UpdateMeasurement(
        int groupId,
        [FromBody] UpdateGroupMeasurementDto request)

    // DELETE /api/groups/{groupId}/measurement
    // Removes measurement (keeps GroupEntry)
    [HttpDelete]
    public async Task<IActionResult> DeleteMeasurement(int groupId)

    // POST /api/groups/{groupId}/measurement/images
    // Uploads original and annotated images
    [HttpPost("images")]
    public async Task<ActionResult<ApiResponse<MeasurementImagesDto>>> UploadMeasurementImages(
        int groupId,
        IFormFile originalImage,
        IFormFile? annotatedImage)
}

// Target PDF Generation
[ApiController]
[Route("api/targets")]
[AllowAnonymous]  // PDFs are public
public class TargetsController : ControllerBase
{
    // GET /api/targets/pdf?type=precision
    // Returns printable PDF
    [HttpGet("pdf")]
    public async Task<IActionResult> GetTargetPdf(
        [FromQuery] string type = "precision",
        [FromQuery] int? sessionId = null)

    // GET /api/targets/types
    // Returns available target types
    [HttpGet("types")]
    public ActionResult<List<TargetTypeDto>> GetTargetTypes()
}
```

### Measurement Calculation Service

```csharp
// TrueDope.Api/Services/GroupMeasurementCalculator.cs

public interface IGroupMeasurementCalculator
{
    GroupMetrics Calculate(
        List<HolePosition> holes,
        decimal bulletDiameter,
        int distanceYards);
}

public class GroupMeasurementCalculator : IGroupMeasurementCalculator
{
    public GroupMetrics Calculate(
        List<HolePosition> holes,
        decimal bulletDiameter,
        int distanceYards)
    {
        if (holes.Count < 2)
            throw new ArgumentException("At least 2 holes required");

        // Calculate centroid
        var centroidX = holes.Average(h => h.X);
        var centroidY = holes.Average(h => h.Y);

        // Calculate extreme spread (max hole-to-hole distance + bullet diameter)
        decimal maxDistance = 0;
        for (int i = 0; i < holes.Count; i++)
        {
            for (int j = i + 1; j < holes.Count; j++)
            {
                var dist = Distance(holes[i], holes[j]);
                if (dist > maxDistance)
                    maxDistance = dist;
            }
        }
        var extremeSpread = maxDistance + bulletDiameter;

        // Calculate mean radius
        var radii = holes.Select(h => Distance(h, new HolePosition { X = centroidX, Y = centroidY }));
        var meanRadius = radii.Average();

        // Calculate spreads
        var horizontalSpread = holes.Max(h => h.X) - holes.Min(h => h.X) + bulletDiameter;
        var verticalSpread = holes.Max(h => h.Y) - holes.Min(h => h.Y) + bulletDiameter;

        // Calculate standard deviations
        var xValues = holes.Select(h => (double)h.X).ToList();
        var yValues = holes.Select(h => (double)h.Y).ToList();
        var horizontalStdDev = (decimal)StandardDeviation(xValues);
        var verticalStdDev = (decimal)StandardDeviation(yValues);

        var radiiList = radii.Select(r => (double)r).ToList();
        var radialStdDev = (decimal)StandardDeviation(radiiList);

        // Calculate CEP (50% circular error probable)
        // Approximate: CEP ≈ 0.5887 * (horizontal_std + vertical_std)
        var cep50 = 0.5887m * (horizontalStdDev + verticalStdDev);

        // POI offset (centroid position = offset from POA at 0,0)
        var poiOffset = new HolePosition { X = centroidX, Y = centroidY };

        // Convert to MOA
        var extremeSpreadMoa = InchesToMoa(extremeSpread, distanceYards);
        var meanRadiusMoa = InchesToMoa(meanRadius, distanceYards);

        return new GroupMetrics
        {
            ExtremeSpread = extremeSpread,
            ExtremeSpreadMoa = extremeSpreadMoa,
            MeanRadius = meanRadius,
            MeanRadiusMoa = meanRadiusMoa,
            HorizontalSpread = horizontalSpread,
            VerticalSpread = verticalSpread,
            RadialStdDev = radialStdDev,
            HorizontalStdDev = horizontalStdDev,
            VerticalStdDev = verticalStdDev,
            Cep50 = cep50,
            Centroid = new HolePosition { X = centroidX, Y = centroidY },
            PoiOffset = poiOffset
        };
    }

    private static decimal Distance(HolePosition a, HolePosition b)
    {
        var dx = a.X - b.X;
        var dy = a.Y - b.Y;
        return (decimal)Math.Sqrt((double)(dx * dx + dy * dy));
    }

    private static decimal InchesToMoa(decimal inches, int distanceYards)
    {
        // MOA = (inches / distance) * (100 / 1.047)
        return (inches / distanceYards) * (100m / 1.047m);
    }

    private static double StandardDeviation(List<double> values)
    {
        var avg = values.Average();
        var sumSquares = values.Sum(v => Math.Pow(v - avg, 2));
        return Math.Sqrt(sumSquares / values.Count);
    }
}
```

---

## Measurement Algorithms

### Fiducial Marker Detection (iOS Vision Framework)

```swift
// Using Vision framework for marker detection

func detectMarkers(in image: CIImage) async throws -> [DetectedMarker] {
    // Vision framework can detect rectangles and QR codes natively
    // For ArUco specifically, we need either:
    // 1. OpenCV (more complex integration)
    // 2. Custom trained CoreML model
    // 3. Simplified square marker detection + ID validation

    // Recommended approach: Use 4 distinctly colored corner markers
    // instead of ArUco for simpler Vision-only detection

    let request = VNDetectRectanglesRequest()
    request.minimumAspectRatio = 0.9
    request.maximumAspectRatio = 1.1
    request.minimumSize = 0.02  // Min 2% of image
    request.maximumObservations = 10

    let handler = VNImageRequestHandler(ciImage: image)
    try handler.perform([request])

    guard let results = request.results else { return [] }

    // Filter to find our 4 corner markers
    // Based on expected positions and marker appearance
    return results.compactMap { observation in
        // Validate this looks like our marker
        // Return DetectedMarker with corner position
    }
}
```

### Perspective Correction

```swift
func correctPerspective(
    image: CIImage,
    markers: [DetectedMarker]
) -> CIImage? {
    guard markers.count == 4 else { return nil }

    // Sort markers by position (TL, TR, BR, BL)
    let sorted = sortMarkersClockwise(markers)

    // Known marker positions on target (in inches)
    let targetCorners: [CGPoint] = [
        CGPoint(x: 0.75, y: 0.75),     // TL
        CGPoint(x: 7.0, y: 0.75),      // TR
        CGPoint(x: 7.0, y: 9.75),      // BR
        CGPoint(x: 0.75, y: 9.75)      // BL
    ]

    // Create perspective transform
    let filter = CIFilter(name: "CIPerspectiveCorrection")!
    filter.setValue(image, forKey: kCIInputImageKey)
    filter.setValue(CIVector(cgPoint: sorted[0].center), forKey: "inputTopLeft")
    filter.setValue(CIVector(cgPoint: sorted[1].center), forKey: "inputTopRight")
    filter.setValue(CIVector(cgPoint: sorted[2].center), forKey: "inputBottomRight")
    filter.setValue(CIVector(cgPoint: sorted[3].center), forKey: "inputBottomLeft")

    return filter.outputImage
}
```

### Hole Detection

```swift
func detectHoles(
    in image: CIImage,
    expectedDiameterPixels: CGFloat,
    gridSpacingPixels: CGFloat
) -> [DetectedHole] {
    // Step 1: Convert to grayscale
    let grayscale = applyGrayscaleFilter(image)

    // Step 2: Apply adaptive threshold
    // Dark holes on light paper = look for dark circles
    let thresholded = applyAdaptiveThreshold(grayscale)

    // Step 3: Find contours/circles using Hough transform
    // Vision framework doesn't have Hough, so we use connected components
    let components = findConnectedComponents(thresholded)

    // Step 4: Filter by size and circularity
    let candidates = components.filter { component in
        let area = component.area
        let expectedArea = .pi * pow(expectedDiameterPixels / 2, 2)
        let areaRatio = area / expectedArea

        // Allow 50% variance in size
        guard areaRatio > 0.5 && areaRatio < 1.5 else { return false }

        // Check circularity (perimeter² / (4π * area) ≈ 1 for circle)
        let circularity = pow(component.perimeter, 2) / (4 * .pi * area)
        return circularity < 1.5
    }

    // Step 5: Convert to DetectedHole with confidence scores
    return candidates.map { component in
        DetectedHole(
            center: component.centroid,
            radius: sqrt(component.area / .pi),
            confidence: calculateConfidence(component),
            position: nil
        )
    }
}
```

---

## Implementation Phases

### MVP Scope (Phases 1-3)

The MVP delivers a fully functional manual measurement tool that works with ANY target. Auto-detection features are future enhancements only.

---

### Phase 1: Backend Foundation
**Scope:** New entity, DTOs, API endpoints, calculation service

**Tasks:**
1. Create `GroupMeasurement` entity and migration
2. Add `GroupMeasurementDto` and request DTOs
3. Implement `GroupMeasurementsController` endpoints
4. Implement `GroupMeasurementCalculator` service
5. Update `GroupEntry` to include optional `Measurement` navigation

**Deliverables:**
- Backend can store and calculate measurements from hole positions

---

### Phase 2: iOS Manual Measurement UI
**Scope:** Camera capture, manual calibration, hole marking

**Tasks:**
1. Create `GroupMeasurementView` flow structure
2. Implement `CaptureStepView` (camera/library picker)
3. Implement `ManualCalibrationView` (user marks known distance)
4. Implement `HoleAdjustmentView` (tap to mark holes, drag to adjust)
5. Implement `MetadataEntryView` (distance, bullet diameter, ammo, notes)
6. Implement `MeasurementReviewView` (display calculated metrics)
7. Add `GroupMeasurement` Swift model
8. Add `GroupMeasurementService` for API calls

**Deliverables:**
- Users can photograph any target
- Manual calibration (mark 1" reference) works
- Tap-to-mark hole interface
- Metrics calculated and displayed

---

### Phase 3: Integration & Polish
**Scope:** Connect to existing flows, image handling, UX refinement

**Tasks:**
1. Integrate measurement flow into `SessionDetailView` (add to existing group, or create new)
2. Add "Measure Group" entry point on GroupEntry cards
3. Upload original + annotated images via existing `ImageService`
4. Update `GroupEntryDto` to include measurement data
5. Display measurement details in group detail view
6. Handle edge cases (< 2 holes, cancel flow, etc.)
7. Polish zoom/pan interactions on image

**Deliverables:**
- Complete manual measurement feature
- Seamless integration with existing session flow

---

### Future Enhancements (Post-MVP)

These are "nice to have" features for future releases. Do not implement until MVP is proven.

#### Future: TrueDope Printable Targets
**Scope:** Custom target PDFs with optional auto-calibration markers

**Why deferred:**
- Manual calibration works with ANY target
- Users already have targets they use
- Build this only if there's demand after MVP launch

**Tasks (when prioritized):**
1. Design target variants (precision, pistol, load dev)
2. Implement PDF generation (backend)
3. Add download endpoints (web + iOS)
4. Optionally add ArUco markers for auto-calibration

---

#### Future: Automatic Target Detection
**Scope:** ArUco marker detection via OpenCV

**Why deferred:**
- Adds ~50MB to app via OpenCV dependency
- Only benefits users of TrueDope-printed targets
- Manual calibration is fast enough for most users

**Tasks (when prioritized):**
1. Add OpenCV Swift package
2. Implement ArUco marker detection
3. Implement perspective correction
4. Auto-calculate calibration from known marker positions
5. Fall back to manual if detection fails

---

#### Future: Automatic Hole Detection
**Scope:** Computer vision hole candidate detection

**Why deferred:**
- Highly variable accuracy based on lighting/target condition
- Overlapping holes (good groups!) are hard to detect
- Manual marking is straightforward and reliable

**Tasks (when prioritized):**
1. Implement adaptive thresholding
2. Implement connected component analysis
3. Filter candidates by size/circularity
4. Present suggestions for user confirmation

---

#### Future: Enhanced Analytics
**Scope:** Comparison views, trends, export

**Tasks (when prioritized):**
1. Group comparison overlay view
2. Historical trend charts
3. PDF report export
4. Share annotated images

---

## Technical Risks & Mitigations (MVP)

### Risk 1: Manual Calibration Accuracy
**Issue:** Users may not accurately mark the reference distance, leading to incorrect measurements.

**Mitigation:**
- Provide clear instructions with visual guides
- Recommend using grid lines on targets for reference
- Show calculated group size in both inches AND MOA so users can sanity-check
- Allow recalibration without losing hole positions

### Risk 2: Print Scaling Issues
**Issue:** Users print targets at "fit to page" instead of 100%, invalidating the grid.

**Mitigation:**
- Bold "PRINT AT 100% SCALE" warning on every PDF
- Include 1" verification ruler graphic on target
- Add instructions: "Measure the ruler with a real ruler before shooting"
- Manual calibration works regardless of print scale

### Risk 3: Image Quality
**Issue:** Blurry, dark, or poorly-framed photos make hole marking difficult.

**Mitigation:**
- Provide photo tips before capture ("hold steady, good lighting, include full target")
- Allow retake from within the flow
- Zoom/pan support for precise hole placement
- Works with photo library selection (user can take best photo separately)

### Risk 4: Zoom/Pan UX Complexity
**Issue:** Pinch-to-zoom + tap-to-mark + drag-to-adjust on same view can conflict.

**Mitigation:**
- Use distinct gestures: pinch for zoom, single tap for add hole, long-press to select, drag to move
- Consider a "mode" toggle if gestures conflict
- Test extensively on device (not just simulator)

### Risk 5: Coordinate System Confusion
**Issue:** Converting between image pixels, screen points, and real-world inches is error-prone.

**Mitigation:**
- Establish clear coordinate system early (document in code)
- All measurements stored in inches relative to POA
- Pixels-per-inch calculated once during calibration, reused throughout
- Unit tests for coordinate transforms

---

## Decisions Made

1. **Fiducial markers:** ArUco (black/white) for future auto-detection. Deferred to post-MVP.

2. **QR code:** Optional future enhancement. Not required for MVP.

3. **Platform:** PDF targets from both web and iOS. Measurement feature iOS-only for MVP, web possible later.

4. **Measurement updates:** Overwrite (no history).

5. **Offline support:** Yes - calculations work offline, sync when connected.

---

## Appendix: File Structure

```
TrueDope/
├── backend/src/TrueDope.Api/
│   ├── Controllers/
│   │   ├── GroupMeasurementsController.cs  (NEW)
│   │   └── TargetsController.cs            (NEW)
│   ├── Data/Entities/
│   │   └── GroupMeasurement.cs             (NEW)
│   ├── DTOs/Sessions/
│   │   └── GroupMeasurementDtos.cs         (NEW)
│   ├── Services/
│   │   ├── GroupMeasurementCalculator.cs   (NEW)
│   │   └── TargetPdfGenerator.cs           (NEW)
│   └── Migrations/
│       └── YYYYMMDD_AddGroupMeasurement.cs (NEW)
│
└── TrueDope-iOS/TrueDope-iOS/
    ├── Models/
    │   └── GroupMeasurement.swift          (NEW)
    ├── Core/Services/
    │   └── GroupMeasurementService.swift   (NEW)
    └── Features/GroupMeasurement/          (NEW)
        ├── Views/
        │   ├── GroupMeasurementView.swift
        │   ├── CaptureStepView.swift
        │   ├── HoleAdjustmentView.swift
        │   ├── MetadataEntryView.swift
        │   ├── MeasurementReviewView.swift
        │   └── ManualCalibrationSheet.swift
        ├── ViewModels/
        │   └── GroupMeasurementViewModel.swift
        └── Components/
            ├── HoleMarker.swift
            ├── POAMarker.swift
            └── ZoomableImageView.swift
```

---

## Document History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-27 | 1.0 | Claude | Initial specification |
