# GMT Phase 1: Backend Implementation Spec

**Date:** 2025-12-28
**Status:** Draft
**Parent Manifest:** [20251227.MANIFEST.md](./20251227.MANIFEST.md)

---

## Overview

Phase 1 implements the backend foundation for group measurements: entity, migration, DTOs, calculation service, and API endpoints. This enables storing detailed hole position data and computing extended group metrics (extreme spread, mean radius, H/V spread, CEP, standard deviations, POI offset).

---

## 1. Entity: GroupMeasurement

**File:** `TrueDope/backend/src/TrueDope.Api/Data/Entities/GroupMeasurement.cs`

```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace TrueDope.Api.Data.Entities;

public class GroupMeasurement
{
    public int Id { get; set; }

    // Parent relationship (1:1 with GroupEntry)
    [Required]
    public int GroupEntryId { get; set; }
    public GroupEntry GroupEntry { get; set; } = null!;

    // Hole position data (stored as JSONB)
    // Array of {x, y} coordinates in inches relative to POA (0,0)
    // Positive X = right of POA, Positive Y = above POA
    [Required]
    [Column(TypeName = "jsonb")]
    public string HolePositionsJson { get; set; } = "[]";

    // Bullet diameter used for edge-to-edge calculations (inches)
    [Required]
    [Column(TypeName = "decimal(5,4)")]
    [Range(0.1, 1.0)]
    public decimal BulletDiameter { get; set; }

    // ==================== Computed Metrics (inches) ====================

    // Extreme spread: max center-to-center + bullet diameter
    [Column(TypeName = "decimal(6,4)")]
    public decimal? ExtremeSpread { get; set; }

    // Mean radius: average distance from centroid
    [Column(TypeName = "decimal(6,4)")]
    public decimal? MeanRadius { get; set; }

    // Horizontal spread: max X - min X + bullet diameter
    [Column(TypeName = "decimal(6,4)")]
    public decimal? HorizontalSpread { get; set; }

    // Vertical spread: max Y - min Y + bullet diameter
    [Column(TypeName = "decimal(6,4)")]
    public decimal? VerticalSpread { get; set; }

    // Standard deviations
    [Column(TypeName = "decimal(6,5)")]
    public decimal? RadialStdDev { get; set; }

    [Column(TypeName = "decimal(6,5)")]
    public decimal? HorizontalStdDev { get; set; }

    [Column(TypeName = "decimal(6,5)")]
    public decimal? VerticalStdDev { get; set; }

    // CEP50: 50% Circular Error Probable (radius containing 50% of shots)
    [Column(TypeName = "decimal(6,4)")]
    public decimal? Cep50 { get; set; }

    // POI offset from POA (group centroid position)
    // Negative X = left of POA, Negative Y = below POA
    [Column(TypeName = "decimal(6,4)")]
    public decimal? PoiOffsetX { get; set; }

    [Column(TypeName = "decimal(6,4)")]
    public decimal? PoiOffsetY { get; set; }

    // ==================== Calibration Metadata ====================

    [Required]
    public CalibrationMethod CalibrationMethod { get; set; } = CalibrationMethod.Manual;

    // Detection/measurement confidence (0.0 - 1.0)
    // null for manual entry, populated for auto-detection
    [Column(TypeName = "decimal(3,2)")]
    [Range(0, 1)]
    public decimal? MeasurementConfidence { get; set; }

    // ==================== Image References ====================
    // These reference Image entities (stored in MinIO)

    public int? OriginalImageId { get; set; }
    public Image? OriginalImage { get; set; }

    public int? AnnotatedImageId { get; set; }
    public Image? AnnotatedImage { get; set; }

    // ==================== Audit ====================

    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
}

public enum CalibrationMethod
{
    Manual = 0,      // User set reference distance manually
    Fiducial = 1,    // TrueDope target with ArUco markers (future)
    QrCode = 2,      // QR code provided calibration data (future)
    GridDetect = 3   // Grid pattern auto-detected (future)
}
```

### Design Decisions

1. **MOA values NOT stored on GroupMeasurement** - MOA conversions depend on distance, which is stored on GroupEntry. Storing MOA would create denormalization issues if distance is updated. Instead:
   - GroupMeasurement stores all values in **inches**
   - When creating/updating a GroupMeasurement, the service updates `GroupEntry.GroupSizeMoa` and `GroupEntry.MeanRadiusMoa` (the existing fields)
   - DTOs can include MOA conversions computed at runtime

2. **Population Standard Deviation** - Using population SD (divide by N) to match `VelocityStatsCalculator` pattern. For typical 3-10 shot groups, the difference from sample SD is minimal.

3. **FK references for images** - `OriginalImageId` and `AnnotatedImageId` provide clean 1:1 relationships rather than using the polymorphic `GroupEntryId` on Image.

4. **JSONB for hole positions** - Efficient storage and querying in PostgreSQL. Array of simple {x, y} objects.

---

## 2. Update GroupEntry Entity

**File:** `TrueDope/backend/src/TrueDope.Api/Data/Entities/GroupEntry.cs`

Add the navigation property:

```csharp
// After existing properties, before computed properties:

// Optional 1:1 detailed measurement data
public GroupMeasurement? Measurement { get; set; }
```

---

## 3. Database Migration

**File:** `TrueDope/backend/src/TrueDope.Api/Migrations/{timestamp}_AddGroupMeasurement.cs`

Run: `cd TrueDope/backend && dotnet ef migrations add AddGroupMeasurement --project src/TrueDope.Api`

The migration should create:
- `GroupMeasurements` table with all columns
- Unique index on `GroupEntryId` (enforces 1:1)
- Foreign key constraints to `GroupEntries`, `Images` (x2)

### DbContext Configuration

**File:** `TrueDope/backend/src/TrueDope.Api/Data/ApplicationDbContext.cs`

Add DbSet and configuration:

```csharp
// Add to DbSets:
public DbSet<GroupMeasurement> GroupMeasurements => Set<GroupMeasurement>();

// Add in OnModelCreating:

// =====================
// GroupMeasurement (1:1 with GroupEntry)
// =====================
builder.Entity<GroupMeasurement>(entity =>
{
    entity.HasOne(m => m.GroupEntry)
        .WithOne(g => g.Measurement)
        .HasForeignKey<GroupMeasurement>(m => m.GroupEntryId)
        .OnDelete(DeleteBehavior.Cascade);

    entity.HasOne(m => m.OriginalImage)
        .WithMany()
        .HasForeignKey(m => m.OriginalImageId)
        .OnDelete(DeleteBehavior.SetNull);

    entity.HasOne(m => m.AnnotatedImage)
        .WithMany()
        .HasForeignKey(m => m.AnnotatedImageId)
        .OnDelete(DeleteBehavior.SetNull);

    // Ensure 1:1 relationship
    entity.HasIndex(m => m.GroupEntryId).IsUnique();

    // Store enum as string
    entity.Property(m => m.CalibrationMethod)
        .HasConversion<string>()
        .HasMaxLength(20);
});
```

---

## 4. DTOs

**File:** `TrueDope/backend/src/TrueDope.Api/DTOs/Sessions/GroupMeasurementDtos.cs`

```csharp
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;

namespace TrueDope.Api.DTOs.Sessions;

// ==================== Hole Position ====================

public class HolePosition
{
    /// <summary>
    /// X coordinate in inches from POA. Positive = right of aim point.
    /// </summary>
    [Required]
    [Range(-10, 10)]
    public decimal X { get; set; }

    /// <summary>
    /// Y coordinate in inches from POA. Positive = above aim point.
    /// </summary>
    [Required]
    [Range(-10, 10)]
    public decimal Y { get; set; }
}

// ==================== Response DTO ====================

public class GroupMeasurementDto
{
    public int Id { get; set; }
    public int GroupEntryId { get; set; }

    // Hole data
    public List<HolePosition> HolePositions { get; set; } = new();
    public decimal BulletDiameter { get; set; }

    // Core metrics (inches)
    public decimal? ExtremeSpread { get; set; }
    public decimal? MeanRadius { get; set; }
    public decimal? HorizontalSpread { get; set; }
    public decimal? VerticalSpread { get; set; }

    // Statistical metrics
    public decimal? RadialStdDev { get; set; }
    public decimal? HorizontalStdDev { get; set; }
    public decimal? VerticalStdDev { get; set; }
    public decimal? Cep50 { get; set; }

    // POI offset from POA
    public decimal? PoiOffsetX { get; set; }
    public decimal? PoiOffsetY { get; set; }

    // MOA conversions (computed from inches + distance)
    public decimal? ExtremeSpreadMoa { get; set; }
    public decimal? MeanRadiusMoa { get; set; }

    // Metadata
    public string CalibrationMethod { get; set; } = string.Empty;
    public decimal? MeasurementConfidence { get; set; }

    // Images
    public ImageDto? OriginalImage { get; set; }
    public ImageDto? AnnotatedImage { get; set; }

    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

// ==================== Create DTO ====================

public class CreateGroupMeasurementDto
{
    /// <summary>
    /// Array of hole positions relative to POA (0,0). Minimum 2 required.
    /// </summary>
    [Required]
    [MinLength(2, ErrorMessage = "At least 2 hole positions are required")]
    public List<HolePosition> HolePositions { get; set; } = new();

    /// <summary>
    /// Bullet diameter in inches (e.g., 0.308 for .308 Win, 0.224 for .223)
    /// </summary>
    [Required]
    [Range(0.1, 1.0, ErrorMessage = "Bullet diameter must be between 0.1 and 1.0 inches")]
    public decimal BulletDiameter { get; set; }

    /// <summary>
    /// How calibration was performed: manual, fiducial, qrCode, gridDetect
    /// </summary>
    [Required]
    public string CalibrationMethod { get; set; } = "manual";

    /// <summary>
    /// Detection confidence (0-1). Optional for manual entry.
    /// </summary>
    [Range(0, 1)]
    public decimal? MeasurementConfidence { get; set; }
}

// ==================== Update DTO ====================

public class UpdateGroupMeasurementDto
{
    /// <summary>
    /// Updated hole positions. If provided, all metrics will be recalculated.
    /// </summary>
    [MinLength(2, ErrorMessage = "At least 2 hole positions are required")]
    public List<HolePosition>? HolePositions { get; set; }

    /// <summary>
    /// Updated bullet diameter. If provided with HolePositions, triggers recalculation.
    /// </summary>
    [Range(0.1, 1.0, ErrorMessage = "Bullet diameter must be between 0.1 and 1.0 inches")]
    public decimal? BulletDiameter { get; set; }

    /// <summary>
    /// Updated calibration method.
    /// </summary>
    public string? CalibrationMethod { get; set; }

    /// <summary>
    /// Updated confidence value.
    /// </summary>
    [Range(0, 1)]
    public decimal? MeasurementConfidence { get; set; }
}
```

### Update GroupEntryDto

**File:** `TrueDope/backend/src/TrueDope.Api/DTOs/Sessions/SessionDtos.cs`

Add measurement to `GroupEntryDto`:

```csharp
public class GroupEntryDto
{
    // ... existing properties ...

    // NEW: Optional detailed measurement data
    public GroupMeasurementDto? Measurement { get; set; }
}
```

---

## 5. Calculation Service

**File:** `TrueDope/backend/src/TrueDope.Api/Services/GroupMeasurementCalculator.cs`

```csharp
namespace TrueDope.Api.Services;

public class GroupMetrics
{
    // All values in inches unless noted
    public decimal ExtremeSpread { get; set; }
    public decimal MeanRadius { get; set; }
    public decimal HorizontalSpread { get; set; }
    public decimal VerticalSpread { get; set; }
    public decimal RadialStdDev { get; set; }
    public decimal HorizontalStdDev { get; set; }
    public decimal VerticalStdDev { get; set; }
    public decimal Cep50 { get; set; }
    public decimal CentroidX { get; set; }
    public decimal CentroidY { get; set; }
}

public interface IGroupMeasurementCalculator
{
    /// <summary>
    /// Calculate all group metrics from hole positions.
    /// </summary>
    /// <param name="holePositions">Array of {X, Y} positions in inches relative to POA</param>
    /// <param name="bulletDiameter">Bullet diameter in inches for edge-to-edge calculation</param>
    /// <returns>Calculated metrics</returns>
    GroupMetrics Calculate(IReadOnlyList<(decimal X, decimal Y)> holePositions, decimal bulletDiameter);

    /// <summary>
    /// Convert inches to MOA at a given distance.
    /// </summary>
    decimal InchesToMoa(decimal inches, int distanceYards);
}

public class GroupMeasurementCalculator : IGroupMeasurementCalculator
{
    public GroupMetrics Calculate(IReadOnlyList<(decimal X, decimal Y)> holePositions, decimal bulletDiameter)
    {
        if (holePositions.Count < 2)
            throw new ArgumentException("At least 2 hole positions are required", nameof(holePositions));

        // ==================== Centroid (POI) ====================
        var centroidX = holePositions.Average(h => h.X);
        var centroidY = holePositions.Average(h => h.Y);

        // ==================== Extreme Spread ====================
        // Maximum center-to-center distance + bullet diameter (edge-to-edge)
        decimal maxCenterToCenter = 0;
        for (int i = 0; i < holePositions.Count; i++)
        {
            for (int j = i + 1; j < holePositions.Count; j++)
            {
                var dist = Distance(holePositions[i], holePositions[j]);
                if (dist > maxCenterToCenter)
                    maxCenterToCenter = dist;
            }
        }
        var extremeSpread = maxCenterToCenter + bulletDiameter;

        // ==================== Mean Radius ====================
        // Average distance from centroid
        var radii = holePositions.Select(h => Distance(h, (centroidX, centroidY))).ToList();
        var meanRadius = radii.Average();

        // ==================== H/V Spread ====================
        var horizontalSpread = holePositions.Max(h => h.X) - holePositions.Min(h => h.X) + bulletDiameter;
        var verticalSpread = holePositions.Max(h => h.Y) - holePositions.Min(h => h.Y) + bulletDiameter;

        // ==================== Standard Deviations ====================
        // Using population standard deviation (divide by N, not N-1)
        var xValues = holePositions.Select(h => (double)h.X).ToList();
        var yValues = holePositions.Select(h => (double)h.Y).ToList();
        var radiiDouble = radii.Select(r => (double)r).ToList();

        var horizontalStdDev = (decimal)PopulationStdDev(xValues);
        var verticalStdDev = (decimal)PopulationStdDev(yValues);
        var radialStdDev = (decimal)PopulationStdDev(radiiDouble);

        // ==================== CEP50 ====================
        // Circular Error Probable - radius containing 50% of shots
        // Approximation: CEP ≈ 0.5887 × (σx + σy) for bivariate normal
        // More accurate for small samples: use median radial distance
        var sortedRadii = radii.OrderBy(r => r).ToList();
        decimal cep50;
        if (sortedRadii.Count >= 2)
        {
            // Use actual median for better accuracy with small groups
            int midIndex = sortedRadii.Count / 2;
            cep50 = sortedRadii.Count % 2 == 0
                ? (sortedRadii[midIndex - 1] + sortedRadii[midIndex]) / 2
                : sortedRadii[midIndex];
        }
        else
        {
            // Fallback to approximation for 2 shots
            cep50 = 0.5887m * (horizontalStdDev + verticalStdDev);
        }

        return new GroupMetrics
        {
            ExtremeSpread = Math.Round(extremeSpread, 4),
            MeanRadius = Math.Round(meanRadius, 4),
            HorizontalSpread = Math.Round(horizontalSpread, 4),
            VerticalSpread = Math.Round(verticalSpread, 4),
            RadialStdDev = Math.Round(radialStdDev, 5),
            HorizontalStdDev = Math.Round(horizontalStdDev, 5),
            VerticalStdDev = Math.Round(verticalStdDev, 5),
            Cep50 = Math.Round(cep50, 4),
            CentroidX = Math.Round(centroidX, 4),
            CentroidY = Math.Round(centroidY, 4)
        };
    }

    public decimal InchesToMoa(decimal inches, int distanceYards)
    {
        if (distanceYards <= 0)
            throw new ArgumentException("Distance must be positive", nameof(distanceYards));

        // 1 MOA = 1.047 inches at 100 yards
        // MOA = (inches / distance) × (100 / 1.047)
        return Math.Round((inches / distanceYards) * (100m / 1.047m), 3);
    }

    private static decimal Distance((decimal X, decimal Y) a, (decimal X, decimal Y) b)
    {
        var dx = a.X - b.X;
        var dy = a.Y - b.Y;
        return (decimal)Math.Sqrt((double)(dx * dx + dy * dy));
    }

    private static double PopulationStdDev(IReadOnlyList<double> values)
    {
        if (values.Count == 0)
            return 0;

        var avg = values.Average();
        var sumOfSquares = values.Sum(v => Math.Pow(v - avg, 2));
        var variance = sumOfSquares / values.Count; // Population variance (N, not N-1)
        return Math.Sqrt(variance);
    }
}
```

### Notes on Calculations

1. **Extreme Spread**: Maximum center-to-center distance + bullet diameter = edge-to-edge measurement. This is what shooters call "group size."

2. **CEP50**: For small shot counts (typical 3-10), using the actual median radial distance is more accurate than the bivariate normal approximation. We use median when n >= 2, falling back to approximation for edge cases.

3. **Population vs Sample SD**: Using population SD (n) rather than sample SD (n-1). For shooting groups, we're measuring the actual population of shots, not estimating a larger population parameter.

---

## 6. Controller

**File:** `TrueDope/backend/src/TrueDope.Api/Controllers/GroupMeasurementsController.cs`

```csharp
using System.Security.Claims;
using System.Text.Json;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TrueDope.Api.Data;
using TrueDope.Api.Data.Entities;
using TrueDope.Api.DTOs;
using TrueDope.Api.DTOs.Sessions;
using TrueDope.Api.Services;

namespace TrueDope.Api.Controllers;

[ApiController]
[Route("api/groups/{groupId:int}/measurement")]
[Authorize]
public class GroupMeasurementsController : ControllerBase
{
    private readonly ApplicationDbContext _context;
    private readonly IGroupMeasurementCalculator _calculator;
    private readonly ILogger<GroupMeasurementsController> _logger;

    public GroupMeasurementsController(
        ApplicationDbContext context,
        IGroupMeasurementCalculator calculator,
        ILogger<GroupMeasurementsController> logger)
    {
        _context = context;
        _calculator = calculator;
        _logger = logger;
    }

    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier)!;

    /// <summary>
    /// Get measurement data for a group entry
    /// </summary>
    [HttpGet]
    [ProducesResponseType(typeof(ApiResponse<GroupMeasurementDto>), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ApiErrorResponse), StatusCodes.Status404NotFound)]
    public async Task<IActionResult> GetMeasurement(int groupId)
    {
        var groupEntry = await GetGroupEntryWithAuth(groupId);
        if (groupEntry == null)
            return NotFound(ApiErrorResponse.Create("GROUP_NOT_FOUND", "Group entry not found"));

        var measurement = await _context.GroupMeasurements
            .Include(m => m.OriginalImage)
            .Include(m => m.AnnotatedImage)
            .FirstOrDefaultAsync(m => m.GroupEntryId == groupId);

        if (measurement == null)
            return NotFound(ApiErrorResponse.Create("MEASUREMENT_NOT_FOUND", "No measurement data for this group"));

        var dto = MapToDto(measurement, groupEntry.Distance);
        return Ok(ApiResponse<GroupMeasurementDto>.Ok(dto));
    }

    /// <summary>
    /// Create measurement data for a group entry
    /// </summary>
    [HttpPost]
    [ProducesResponseType(typeof(ApiResponse<GroupMeasurementDto>), StatusCodes.Status201Created)]
    [ProducesResponseType(typeof(ApiErrorResponse), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(ApiErrorResponse), StatusCodes.Status404NotFound)]
    [ProducesResponseType(typeof(ApiErrorResponse), StatusCodes.Status409Conflict)]
    public async Task<IActionResult> CreateMeasurement(int groupId, [FromBody] CreateGroupMeasurementDto dto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ApiErrorResponse.ValidationError("Validation failed", GetValidationErrors()));

        var groupEntry = await GetGroupEntryWithAuth(groupId);
        if (groupEntry == null)
            return NotFound(ApiErrorResponse.Create("GROUP_NOT_FOUND", "Group entry not found"));

        // Check if measurement already exists
        var existing = await _context.GroupMeasurements.AnyAsync(m => m.GroupEntryId == groupId);
        if (existing)
            return Conflict(ApiErrorResponse.Create("MEASUREMENT_EXISTS", "Measurement already exists for this group. Use PUT to update."));

        // Parse calibration method
        if (!Enum.TryParse<CalibrationMethod>(dto.CalibrationMethod, true, out var calibrationMethod))
            return BadRequest(ApiErrorResponse.Create("INVALID_CALIBRATION_METHOD", $"Invalid calibration method. Valid values: {string.Join(", ", Enum.GetNames<CalibrationMethod>())}"));

        // Calculate metrics
        var holePositions = dto.HolePositions.Select(h => (h.X, h.Y)).ToList();
        var metrics = _calculator.Calculate(holePositions, dto.BulletDiameter);

        // Create entity
        var measurement = new GroupMeasurement
        {
            GroupEntryId = groupId,
            HolePositionsJson = JsonSerializer.Serialize(dto.HolePositions),
            BulletDiameter = dto.BulletDiameter,
            ExtremeSpread = metrics.ExtremeSpread,
            MeanRadius = metrics.MeanRadius,
            HorizontalSpread = metrics.HorizontalSpread,
            VerticalSpread = metrics.VerticalSpread,
            RadialStdDev = metrics.RadialStdDev,
            HorizontalStdDev = metrics.HorizontalStdDev,
            VerticalStdDev = metrics.VerticalStdDev,
            Cep50 = metrics.Cep50,
            PoiOffsetX = metrics.CentroidX,
            PoiOffsetY = metrics.CentroidY,
            CalibrationMethod = calibrationMethod,
            MeasurementConfidence = dto.MeasurementConfidence
        };

        _context.GroupMeasurements.Add(measurement);

        // Update GroupEntry with MOA values
        groupEntry.GroupSizeMoa = _calculator.InchesToMoa(metrics.ExtremeSpread, groupEntry.Distance);
        groupEntry.MeanRadiusMoa = _calculator.InchesToMoa(metrics.MeanRadius, groupEntry.Distance);
        groupEntry.NumberOfShots = dto.HolePositions.Count;
        groupEntry.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        _logger.LogInformation("Created measurement for group {GroupId} with {HoleCount} holes", groupId, dto.HolePositions.Count);

        var resultDto = MapToDto(measurement, groupEntry.Distance);
        return CreatedAtAction(nameof(GetMeasurement), new { groupId },
            ApiResponse<GroupMeasurementDto>.Ok(resultDto, "Measurement created successfully"));
    }

    /// <summary>
    /// Update measurement data for a group entry
    /// </summary>
    [HttpPut]
    [ProducesResponseType(typeof(ApiResponse<GroupMeasurementDto>), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ApiErrorResponse), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(ApiErrorResponse), StatusCodes.Status404NotFound)]
    public async Task<IActionResult> UpdateMeasurement(int groupId, [FromBody] UpdateGroupMeasurementDto dto)
    {
        if (!ModelState.IsValid)
            return BadRequest(ApiErrorResponse.ValidationError("Validation failed", GetValidationErrors()));

        var groupEntry = await GetGroupEntryWithAuth(groupId);
        if (groupEntry == null)
            return NotFound(ApiErrorResponse.Create("GROUP_NOT_FOUND", "Group entry not found"));

        var measurement = await _context.GroupMeasurements
            .Include(m => m.OriginalImage)
            .Include(m => m.AnnotatedImage)
            .FirstOrDefaultAsync(m => m.GroupEntryId == groupId);

        if (measurement == null)
            return NotFound(ApiErrorResponse.Create("MEASUREMENT_NOT_FOUND", "No measurement data for this group. Use POST to create."));

        // Update calibration method if provided
        if (dto.CalibrationMethod != null)
        {
            if (!Enum.TryParse<CalibrationMethod>(dto.CalibrationMethod, true, out var calibrationMethod))
                return BadRequest(ApiErrorResponse.Create("INVALID_CALIBRATION_METHOD", $"Invalid calibration method. Valid values: {string.Join(", ", Enum.GetNames<CalibrationMethod>())}"));
            measurement.CalibrationMethod = calibrationMethod;
        }

        if (dto.MeasurementConfidence.HasValue)
            measurement.MeasurementConfidence = dto.MeasurementConfidence;

        // If hole positions or bullet diameter changed, recalculate everything
        if (dto.HolePositions != null || dto.BulletDiameter.HasValue)
        {
            var holePositions = dto.HolePositions ??
                JsonSerializer.Deserialize<List<HolePosition>>(measurement.HolePositionsJson) ??
                new List<HolePosition>();

            var bulletDiameter = dto.BulletDiameter ?? measurement.BulletDiameter;

            if (holePositions.Count < 2)
                return BadRequest(ApiErrorResponse.Create("INVALID_HOLES", "At least 2 hole positions are required"));

            var metrics = _calculator.Calculate(holePositions.Select(h => (h.X, h.Y)).ToList(), bulletDiameter);

            measurement.HolePositionsJson = JsonSerializer.Serialize(holePositions);
            measurement.BulletDiameter = bulletDiameter;
            measurement.ExtremeSpread = metrics.ExtremeSpread;
            measurement.MeanRadius = metrics.MeanRadius;
            measurement.HorizontalSpread = metrics.HorizontalSpread;
            measurement.VerticalSpread = metrics.VerticalSpread;
            measurement.RadialStdDev = metrics.RadialStdDev;
            measurement.HorizontalStdDev = metrics.HorizontalStdDev;
            measurement.VerticalStdDev = metrics.VerticalStdDev;
            measurement.Cep50 = metrics.Cep50;
            measurement.PoiOffsetX = metrics.CentroidX;
            measurement.PoiOffsetY = metrics.CentroidY;

            // Update GroupEntry MOA values
            groupEntry.GroupSizeMoa = _calculator.InchesToMoa(metrics.ExtremeSpread, groupEntry.Distance);
            groupEntry.MeanRadiusMoa = _calculator.InchesToMoa(metrics.MeanRadius, groupEntry.Distance);
            groupEntry.NumberOfShots = holePositions.Count;
        }

        measurement.UpdatedAt = DateTime.UtcNow;
        groupEntry.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync();

        _logger.LogInformation("Updated measurement for group {GroupId}", groupId);

        var resultDto = MapToDto(measurement, groupEntry.Distance);
        return Ok(ApiResponse<GroupMeasurementDto>.Ok(resultDto, "Measurement updated successfully"));
    }

    /// <summary>
    /// Delete measurement data for a group entry
    /// </summary>
    [HttpDelete]
    [ProducesResponseType(typeof(ApiResponse), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(ApiErrorResponse), StatusCodes.Status404NotFound)]
    public async Task<IActionResult> DeleteMeasurement(int groupId)
    {
        var groupEntry = await GetGroupEntryWithAuth(groupId);
        if (groupEntry == null)
            return NotFound(ApiErrorResponse.Create("GROUP_NOT_FOUND", "Group entry not found"));

        var measurement = await _context.GroupMeasurements.FirstOrDefaultAsync(m => m.GroupEntryId == groupId);
        if (measurement == null)
            return NotFound(ApiErrorResponse.Create("MEASUREMENT_NOT_FOUND", "No measurement data for this group"));

        _context.GroupMeasurements.Remove(measurement);

        // Note: We do NOT clear GroupEntry.GroupSizeMoa/MeanRadiusMoa
        // The user may want to keep those values even after removing detailed measurement

        await _context.SaveChangesAsync();

        _logger.LogInformation("Deleted measurement for group {GroupId}", groupId);

        return Ok(ApiResponse.Ok("Measurement deleted successfully"));
    }

    // ==================== Private Helpers ====================

    private async Task<GroupEntry?> GetGroupEntryWithAuth(int groupId)
    {
        var userId = GetUserId();
        return await _context.GroupEntries
            .Include(g => g.RangeSession)
            .FirstOrDefaultAsync(g => g.Id == groupId && g.RangeSession.UserId == userId);
    }

    private GroupMeasurementDto MapToDto(GroupMeasurement measurement, int distanceYards)
    {
        var holePositions = JsonSerializer.Deserialize<List<HolePosition>>(measurement.HolePositionsJson)
            ?? new List<HolePosition>();

        return new GroupMeasurementDto
        {
            Id = measurement.Id,
            GroupEntryId = measurement.GroupEntryId,
            HolePositions = holePositions,
            BulletDiameter = measurement.BulletDiameter,
            ExtremeSpread = measurement.ExtremeSpread,
            MeanRadius = measurement.MeanRadius,
            HorizontalSpread = measurement.HorizontalSpread,
            VerticalSpread = measurement.VerticalSpread,
            RadialStdDev = measurement.RadialStdDev,
            HorizontalStdDev = measurement.HorizontalStdDev,
            VerticalStdDev = measurement.VerticalStdDev,
            Cep50 = measurement.Cep50,
            PoiOffsetX = measurement.PoiOffsetX,
            PoiOffsetY = measurement.PoiOffsetY,
            ExtremeSpreadMoa = measurement.ExtremeSpread.HasValue
                ? _calculator.InchesToMoa(measurement.ExtremeSpread.Value, distanceYards)
                : null,
            MeanRadiusMoa = measurement.MeanRadius.HasValue
                ? _calculator.InchesToMoa(measurement.MeanRadius.Value, distanceYards)
                : null,
            CalibrationMethod = measurement.CalibrationMethod.ToString().ToLowerInvariant(),
            MeasurementConfidence = measurement.MeasurementConfidence,
            OriginalImage = measurement.OriginalImage != null ? MapImageDto(measurement.OriginalImage) : null,
            AnnotatedImage = measurement.AnnotatedImage != null ? MapImageDto(measurement.AnnotatedImage) : null,
            CreatedAt = measurement.CreatedAt,
            UpdatedAt = measurement.UpdatedAt
        };
    }

    private static ImageDto MapImageDto(Image image)
    {
        return new ImageDto
        {
            Id = image.Id,
            Url = $"/api/images/{image.Id}",
            ThumbnailUrl = $"/api/images/{image.Id}/thumbnail",
            Caption = image.Caption,
            OriginalFileName = image.OriginalFileName,
            FileSize = image.FileSize
        };
    }

    private Dictionary<string, string[]> GetValidationErrors()
    {
        return ModelState
            .Where(x => x.Value?.Errors.Count > 0)
            .ToDictionary(
                x => x.Key,
                x => x.Value!.Errors.Select(e => e.ErrorMessage).ToArray()
            );
    }
}
```

---

## 7. Update SessionService to Include Measurements

When loading GroupEntries, optionally include Measurement data.

**File:** `TrueDope/backend/src/TrueDope.Api/Services/SessionService.cs`

In `GetSessionAsync` method, update the query to include measurements:

```csharp
// When loading GroupEntries, include Measurement
.Include(s => s.GroupEntries)
    .ThenInclude(g => g.Measurement)
        .ThenInclude(m => m!.OriginalImage)
.Include(s => s.GroupEntries)
    .ThenInclude(g => g.Measurement)
        .ThenInclude(m => m!.AnnotatedImage)
```

And update the DTO mapping to include measurement data in `GroupEntryDto`.

---

## 8. DI Registration

**File:** `TrueDope/backend/src/TrueDope.Api/Program.cs`

Add service registration:

```csharp
// Add with other service registrations
builder.Services.AddScoped<IGroupMeasurementCalculator, GroupMeasurementCalculator>();
```

---

## 9. API Summary

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/groups/{groupId}/measurement` | Get measurement for a group |
| POST | `/api/groups/{groupId}/measurement` | Create measurement (calculates metrics) |
| PUT | `/api/groups/{groupId}/measurement` | Update measurement (recalculates if holes change) |
| DELETE | `/api/groups/{groupId}/measurement` | Delete measurement (keeps GroupEntry) |

### Request/Response Examples

**POST /api/groups/42/measurement**
```json
{
  "holePositions": [
    { "x": 0.125, "y": 0.250 },
    { "x": -0.100, "y": 0.150 },
    { "x": 0.050, "y": -0.175 },
    { "x": -0.200, "y": -0.100 },
    { "x": 0.175, "y": 0.025 }
  ],
  "bulletDiameter": 0.308,
  "calibrationMethod": "manual",
  "measurementConfidence": null
}
```

**Response (201 Created)**
```json
{
  "success": true,
  "data": {
    "id": 1,
    "groupEntryId": 42,
    "holePositions": [...],
    "bulletDiameter": 0.308,
    "extremeSpread": 0.7330,
    "meanRadius": 0.2156,
    "horizontalSpread": 0.6830,
    "verticalSpread": 0.7330,
    "radialStdDev": 0.08234,
    "horizontalStdDev": 0.14521,
    "verticalStdDev": 0.16234,
    "cep50": 0.1875,
    "poiOffsetX": 0.0100,
    "poiOffsetY": 0.0300,
    "extremeSpreadMoa": 0.700,
    "meanRadiusMoa": 0.206,
    "calibrationMethod": "manual",
    "measurementConfidence": null,
    "originalImage": null,
    "annotatedImage": null,
    "createdAt": "2025-12-28T10:30:00Z",
    "updatedAt": "2025-12-28T10:30:00Z"
  },
  "message": "Measurement created successfully"
}
```

---

## 10. Testing Checklist

### Unit Tests (GroupMeasurementCalculator)

- [ ] Calculate with 2 holes - minimum case
- [ ] Calculate with 5 holes - typical case
- [ ] Calculate with 10 holes - larger group
- [ ] Verify extreme spread includes bullet diameter
- [ ] Verify H/V spread includes bullet diameter
- [ ] Verify centroid is correct average
- [ ] Verify CEP50 uses median for n >= 3
- [ ] InchesToMoa at 100 yards: 1.047" = 1 MOA
- [ ] InchesToMoa at 200 yards: 2.094" = 1 MOA
- [ ] Throw ArgumentException for < 2 holes
- [ ] Throw ArgumentException for distance <= 0

### Integration Tests (API Endpoints)

- [ ] GET returns 404 when no measurement exists
- [ ] POST creates measurement and updates GroupEntry MOA values
- [ ] POST returns 409 if measurement already exists
- [ ] POST validates minimum 2 holes
- [ ] POST validates bullet diameter range
- [ ] PUT recalculates on hole position change
- [ ] PUT recalculates on bullet diameter change
- [ ] DELETE removes measurement but keeps GroupEntry
- [ ] Auth: Cannot access other user's groups

---

## 11. File Checklist

| File | Action |
|------|--------|
| `Data/Entities/GroupMeasurement.cs` | Create |
| `Data/Entities/GroupEntry.cs` | Add `Measurement` property |
| `Data/ApplicationDbContext.cs` | Add DbSet + configuration |
| `Migrations/*_AddGroupMeasurement.cs` | Generate |
| `DTOs/Sessions/GroupMeasurementDtos.cs` | Create |
| `DTOs/Sessions/SessionDtos.cs` | Update `GroupEntryDto` |
| `Services/GroupMeasurementCalculator.cs` | Create |
| `Controllers/GroupMeasurementsController.cs` | Create |
| `Services/SessionService.cs` | Update to include Measurement |
| `Program.cs` | Register calculator service |

---

## Document History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-28 | 1.0 | Claude | Initial specification |
