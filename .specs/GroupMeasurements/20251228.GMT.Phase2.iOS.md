# GMT Phase 2: iOS Manual Measurement UI Spec

**Date:** 2025-12-28
**Status:** Draft
**Parent Manifest:** [20251227.MANIFEST.md](./20251227.MANIFEST.md)
**Depends On:** [Phase 1 Backend](./20251228.GMT.Phase1.Backend.md)

---

## Overview

Phase 2 implements the iOS manual measurement UI flow. Users can photograph any target, manually calibrate by marking a known distance, tap to mark hole positions, and save detailed measurement data to the backend.

**Scope:**
- Camera/photo library capture
- Manual calibration (mark two points representing known distance)
- Tap-to-mark hole positions on image
- Metadata entry (bullet diameter, distance already on GroupEntry)
- Metrics display and review
- API integration with Phase 1 endpoints

**Out of Scope (Future):**
- Automatic target detection (ArUco markers)
- Automatic hole detection
- TrueDope printable targets

---

## 1. User Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                     ENTRY POINTS                                 │
├─────────────────────────────────────────────────────────────────┤
│  1. SessionDetailView → GroupEntry card → "Measure" button      │
│  2. GroupEntryForm → "Measure from Photo" option                │
│  3. Add Group → "Add with Measurement" flow                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 1: CAPTURE                                                │
│  ─────────────────                                              │
│  • Show camera/library picker (existing ImagePickerSheet)       │
│  • User captures or selects target photo                        │
│  • Photo tips overlay: "Include full target, good lighting"     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 2: CALIBRATION                                            │
│  ──────────────────                                             │
│  • Display image with zoom/pan                                  │
│  • Instructions: "Tap two points that are 1 inch apart"         │
│  • User taps point 1 → marker appears                           │
│  • User taps point 2 → marker appears, line drawn               │
│  • Input field to adjust reference distance (default 1.0")      │
│  • "Confirm Calibration" button                                 │
│  • Shows calculated pixels-per-inch for validation              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 3: MARK HOLES                                             │
│  ─────────────────                                              │
│  • Display calibrated image with zoom/pan                       │
│  • Instructions: "Tap center of each bullet hole"               │
│  • Tap to add hole marker (numbered circle)                     │
│  • Long-press existing marker to select (shows delete option)   │
│  • Drag selected marker to adjust position                      │
│  • Tap POA crosshair icon → tap image to set POA location       │
│  • Show hole count in toolbar                                   │
│  • "Continue" button (enabled when >= 2 holes)                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 4: METADATA                                               │
│  ───────────────                                                │
│  • Bullet diameter picker (common calibers + custom)            │
│  • Distance (pre-filled from GroupEntry if editing)             │
│  • Optional: Ammunition selection                               │
│  • Optional: Notes                                              │
│  • "Calculate" button                                           │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 5: REVIEW                                                 │
│  ────────────                                                   │
│  • Show annotated image preview                                 │
│  • Display calculated metrics:                                  │
│    - Group Size (ES): X.XXX" / X.XX MOA                        │
│    - Mean Radius: X.XXX" / X.XX MOA                            │
│    - H Spread / V Spread                                        │
│    - CEP50, Std Devs (collapsible advanced section)            │
│    - POI Offset from POA                                        │
│  • "Save" button → uploads to API                               │
│  • "Edit Holes" button → back to step 3                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  COMPLETION                                                     │
│  ──────────                                                     │
│  • Success feedback                                             │
│  • Dismiss sheet                                                │
│  • Parent view refreshes to show measurement data               │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. File Structure

```
TrueDope-iOS/TrueDope-iOS/
├── Features/
│   └── GroupMeasurement/                    # NEW FEATURE MODULE
│       ├── Views/
│       │   ├── GroupMeasurementFlow.swift   # Main container/coordinator
│       │   ├── CaptureStepView.swift        # Step 1: Photo capture
│       │   ├── CalibrationStepView.swift    # Step 2: Manual calibration
│       │   ├── HoleMarkingView.swift        # Step 3: Mark holes
│       │   ├── MeasurementMetadataView.swift # Step 4: Bullet diameter, etc
│       │   └── MeasurementReviewView.swift  # Step 5: Results review
│       ├── ViewModels/
│       │   └── GroupMeasurementViewModel.swift
│       └── Components/
│           ├── ZoomableImageView.swift      # Pinch-to-zoom image container
│           ├── HoleMarker.swift             # Numbered hole circle overlay
│           ├── POAMarker.swift              # Crosshair overlay for POA
│           ├── CalibrationLine.swift        # Line between calibration points
│           └── BulletDiameterPicker.swift   # Common caliber picker
│
├── Models/
│   └── GroupMeasurement.swift               # NEW - mirrors backend DTOs
│
├── Core/
│   └── Network/
│       └── APIEndpoints.swift               # ADD measurement endpoints
│
└── Services/                                # Or Core/Services/
    └── GroupMeasurementService.swift        # NEW - API calls
```

---

## 3. Models

**File:** `TrueDope-iOS/TrueDope-iOS/Models/GroupMeasurement.swift`

```swift
import Foundation
import CoreGraphics

// MARK: - Hole Position

struct HolePosition: Codable, Hashable, Identifiable {
    var id: String { "\(x),\(y)" }
    let x: Decimal  // inches from POA, positive = right
    let y: Decimal  // inches from POA, positive = up

    var cgPoint: CGPoint {
        CGPoint(
            x: CGFloat(truncating: x as NSNumber),
            y: CGFloat(truncating: y as NSNumber)
        )
    }

    init(x: Decimal, y: Decimal) {
        self.x = x
        self.y = y
    }

    init(cgPoint: CGPoint) {
        self.x = Decimal(Double(cgPoint.x))
        self.y = Decimal(Double(cgPoint.y))
    }
}

// MARK: - Calibration Method

enum CalibrationMethod: String, Codable, CaseIterable {
    case manual = "manual"
    case fiducial = "fiducial"
    case qrCode = "qrCode"
    case gridDetect = "gridDetect"

    var displayName: String {
        switch self {
        case .manual: return "Manual"
        case .fiducial: return "TrueDope Target"
        case .qrCode: return "QR Code"
        case .gridDetect: return "Grid Detection"
        }
    }
}

// MARK: - Group Measurement Response

struct GroupMeasurement: Codable, Identifiable {
    let id: Int
    let groupEntryId: Int
    let holePositions: [HolePosition]
    let bulletDiameter: Decimal

    // Metrics (inches)
    let extremeSpread: Decimal?
    let meanRadius: Decimal?
    let horizontalSpread: Decimal?
    let verticalSpread: Decimal?
    let radialStdDev: Decimal?
    let horizontalStdDev: Decimal?
    let verticalStdDev: Decimal?
    let cep50: Decimal?

    // POI offset
    let poiOffsetX: Decimal?
    let poiOffsetY: Decimal?

    // MOA (computed by backend)
    let extremeSpreadMoa: Decimal?
    let meanRadiusMoa: Decimal?

    // Metadata
    let calibrationMethod: String
    let measurementConfidence: Decimal?

    // Images
    let originalImage: GroupImage?
    let annotatedImage: GroupImage?

    let createdAt: Date
    let updatedAt: Date

    // MARK: - Computed Properties

    var shotCount: Int { holePositions.count }

    var formattedExtremeSpread: String? {
        guard let es = extremeSpread else { return nil }
        return String(format: "%.3f\"", NSDecimalNumber(decimal: es).doubleValue)
    }

    var formattedExtremeSpreadMoa: String? {
        guard let moa = extremeSpreadMoa else { return nil }
        return String(format: "%.2f MOA", NSDecimalNumber(decimal: moa).doubleValue)
    }

    var formattedMeanRadius: String? {
        guard let mr = meanRadius else { return nil }
        return String(format: "%.3f\"", NSDecimalNumber(decimal: mr).doubleValue)
    }

    var formattedMeanRadiusMoa: String? {
        guard let moa = meanRadiusMoa else { return nil }
        return String(format: "%.2f MOA", NSDecimalNumber(decimal: moa).doubleValue)
    }

    var poiOffsetDescription: String? {
        guard let x = poiOffsetX, let y = poiOffsetY else { return nil }
        let xVal = NSDecimalNumber(decimal: x).doubleValue
        let yVal = NSDecimalNumber(decimal: y).doubleValue
        let xDir = xVal >= 0 ? "R" : "L"
        let yDir = yVal >= 0 ? "H" : "L"
        return String(format: "%.2f\" %@, %.2f\" %@", abs(xVal), xDir, abs(yVal), yDir)
    }
}

// MARK: - Create Request

struct CreateGroupMeasurementRequest: Codable {
    let holePositions: [HolePosition]
    let bulletDiameter: Decimal
    let calibrationMethod: String
    let measurementConfidence: Decimal?

    init(
        holePositions: [HolePosition],
        bulletDiameter: Decimal,
        calibrationMethod: CalibrationMethod = .manual,
        measurementConfidence: Decimal? = nil
    ) {
        self.holePositions = holePositions
        self.bulletDiameter = bulletDiameter
        self.calibrationMethod = calibrationMethod.rawValue
        self.measurementConfidence = measurementConfidence
    }
}

// MARK: - Update Request

struct UpdateGroupMeasurementRequest: Codable {
    var holePositions: [HolePosition]?
    var bulletDiameter: Decimal?
    var calibrationMethod: String?
    var measurementConfidence: Decimal?
}

// MARK: - Common Bullet Diameters

enum CommonBulletDiameter: CaseIterable {
    case cal22      // .224"
    case cal243     // .243"
    case cal264     // .264" (6.5mm)
    case cal284     // .284" (7mm)
    case cal308     // .308"
    case cal338     // .338"
    case cal45      // .452"
    case cal50      // .510"

    var diameter: Decimal {
        switch self {
        case .cal22: return 0.224
        case .cal243: return 0.243
        case .cal264: return 0.264
        case .cal284: return 0.284
        case .cal308: return 0.308
        case .cal338: return 0.338
        case .cal45: return 0.452
        case .cal50: return 0.510
        }
    }

    var displayName: String {
        switch self {
        case .cal22: return ".22 Cal (.224\")"
        case .cal243: return ".243 Cal"
        case .cal264: return "6.5mm (.264\")"
        case .cal284: return "7mm (.284\")"
        case .cal308: return ".30 Cal (.308\")"
        case .cal338: return ".338 Cal"
        case .cal45: return ".45 Cal (.452\")"
        case .cal50: return ".50 Cal (.510\")"
        }
    }
}
```

---

## 4. API Endpoints

**File:** `TrueDope-iOS/TrueDope-iOS/Core/Network/APIEndpoints.swift`

Add to existing file:

```swift
// MARK: - Group Measurements

enum GroupMeasurements: APIEndpoint {
    case get(groupId: Int)
    case create(groupId: Int)
    case update(groupId: Int)
    case delete(groupId: Int)

    var path: String {
        switch self {
        case .get(let groupId),
             .create(let groupId),
             .update(let groupId),
             .delete(let groupId):
            return "/groups/\(groupId)/measurement"
        }
    }

    var method: HTTPMethod {
        switch self {
        case .get: return .get
        case .create: return .post
        case .update: return .put
        case .delete: return .delete
        }
    }
}
```

---

## 5. Service Layer

**File:** `TrueDope-iOS/TrueDope-iOS/Services/GroupMeasurementService.swift`

```swift
import UIKit

protocol GroupMeasurementServiceProtocol {
    func getMeasurement(groupId: Int) async throws -> GroupMeasurement?
    func createMeasurement(groupId: Int, request: CreateGroupMeasurementRequest) async throws -> GroupMeasurement
    func updateMeasurement(groupId: Int, request: UpdateGroupMeasurementRequest) async throws -> GroupMeasurement
    func deleteMeasurement(groupId: Int) async throws
}

final class GroupMeasurementService: GroupMeasurementServiceProtocol {
    static let shared = GroupMeasurementService()

    private let apiClient = APIClient.shared

    private init() {}

    func getMeasurement(groupId: Int) async throws -> GroupMeasurement? {
        do {
            let response: APIResponse<GroupMeasurement> = try await apiClient.requestData(
                GroupMeasurements.get(groupId: groupId)
            )
            return response.data
        } catch let error as APIError {
            // 404 means no measurement exists - not an error
            if case .httpError(let code, _) = error, code == 404 {
                return nil
            }
            throw error
        }
    }

    func createMeasurement(groupId: Int, request: CreateGroupMeasurementRequest) async throws -> GroupMeasurement {
        let response: APIResponse<GroupMeasurement> = try await apiClient.requestData(
            GroupMeasurements.create(groupId: groupId),
            body: request
        )
        guard let measurement = response.data else {
            throw APIError.decodingError
        }
        return measurement
    }

    func updateMeasurement(groupId: Int, request: UpdateGroupMeasurementRequest) async throws -> GroupMeasurement {
        let response: APIResponse<GroupMeasurement> = try await apiClient.requestData(
            GroupMeasurements.update(groupId: groupId),
            body: request
        )
        guard let measurement = response.data else {
            throw APIError.decodingError
        }
        return measurement
    }

    func deleteMeasurement(groupId: Int) async throws {
        try await apiClient.requestVoid(GroupMeasurements.delete(groupId: groupId))
    }
}
```

---

## 6. ViewModel

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/ViewModels/GroupMeasurementViewModel.swift`

```swift
import SwiftUI
import Combine

@MainActor
final class GroupMeasurementViewModel: ObservableObject {

    // MARK: - Flow State

    enum Step: Int, CaseIterable {
        case capture = 0
        case calibration = 1
        case markHoles = 2
        case metadata = 3
        case review = 4
    }

    @Published var currentStep: Step = .capture
    @Published var isLoading = false
    @Published var isSaving = false
    @Published var error: String?
    @Published var showError = false

    // MARK: - Capture State

    @Published var capturedImage: UIImage?

    // MARK: - Calibration State

    @Published var calibrationPoint1: CGPoint?
    @Published var calibrationPoint2: CGPoint?
    @Published var referenceDistanceInches: Decimal = 1.0
    @Published var pixelsPerInch: CGFloat?

    // MARK: - Hole Marking State

    /// Hole positions in IMAGE COORDINATES (pixels)
    @Published var holeMarkersPixels: [CGPoint] = []
    /// POA position in IMAGE COORDINATES (pixels) - default center of image
    @Published var poaPositionPixels: CGPoint?
    @Published var selectedHoleIndex: Int?
    @Published var isSettingPOA = false

    // MARK: - Metadata State

    @Published var bulletDiameter: Decimal = 0.308
    @Published var selectedCommonDiameter: CommonBulletDiameter? = .cal308
    @Published var useCustomDiameter = false

    // MARK: - Results

    @Published var calculatedMeasurement: GroupMeasurement?
    @Published var annotatedImage: UIImage?

    // MARK: - Context

    let groupId: Int
    let distance: Int  // From GroupEntry
    let existingMeasurement: GroupMeasurement?

    private let measurementService: GroupMeasurementServiceProtocol

    // MARK: - Init

    init(
        groupId: Int,
        distance: Int,
        existingMeasurement: GroupMeasurement? = nil,
        measurementService: GroupMeasurementServiceProtocol = GroupMeasurementService.shared
    ) {
        self.groupId = groupId
        self.distance = distance
        self.existingMeasurement = existingMeasurement
        self.measurementService = measurementService

        // If editing existing measurement, we'd need to load the original image
        // For MVP, we start fresh each time
    }

    // MARK: - Computed Properties

    var canProceedFromCalibration: Bool {
        calibrationPoint1 != nil && calibrationPoint2 != nil && pixelsPerInch != nil
    }

    var canProceedFromHoleMarking: Bool {
        holeMarkersPixels.count >= 2
    }

    var holeCount: Int { holeMarkersPixels.count }

    // MARK: - Navigation

    func goToNextStep() {
        guard let nextStep = Step(rawValue: currentStep.rawValue + 1) else { return }

        // Perform step transition logic
        switch currentStep {
        case .calibration:
            calculatePixelsPerInch()
        case .markHoles:
            // Convert pixel positions to inches before metadata step
            break
        case .metadata:
            Task { await calculateMetrics() }
        default:
            break
        }

        currentStep = nextStep
    }

    func goToPreviousStep() {
        guard let prevStep = Step(rawValue: currentStep.rawValue - 1) else { return }
        currentStep = prevStep
    }

    func goToStep(_ step: Step) {
        currentStep = step
    }

    // MARK: - Calibration

    func calculatePixelsPerInch() {
        guard let p1 = calibrationPoint1, let p2 = calibrationPoint2 else {
            pixelsPerInch = nil
            return
        }

        let distancePixels = hypot(p2.x - p1.x, p2.y - p1.y)
        let refDistanceDouble = NSDecimalNumber(decimal: referenceDistanceInches).doubleValue

        guard refDistanceDouble > 0 else {
            pixelsPerInch = nil
            return
        }

        pixelsPerInch = distancePixels / CGFloat(refDistanceDouble)
    }

    func resetCalibration() {
        calibrationPoint1 = nil
        calibrationPoint2 = nil
        pixelsPerInch = nil
    }

    // MARK: - Hole Marking

    func addHole(at pixelPosition: CGPoint) {
        holeMarkersPixels.append(pixelPosition)
    }

    func removeHole(at index: Int) {
        guard index >= 0 && index < holeMarkersPixels.count else { return }
        holeMarkersPixels.remove(at: index)
        selectedHoleIndex = nil
    }

    func removeSelectedHole() {
        guard let index = selectedHoleIndex else { return }
        removeHole(at: index)
    }

    func updateHolePosition(at index: Int, to newPosition: CGPoint) {
        guard index >= 0 && index < holeMarkersPixels.count else { return }
        holeMarkersPixels[index] = newPosition
    }

    func setPOA(at pixelPosition: CGPoint) {
        poaPositionPixels = pixelPosition
        isSettingPOA = false
    }

    // MARK: - Coordinate Conversion

    /// Convert pixel position to inches relative to POA
    func pixelsToInches(_ pixelPosition: CGPoint) -> HolePosition? {
        guard let ppi = pixelsPerInch, ppi > 0 else { return nil }

        // Default POA to image center if not set
        let poa = poaPositionPixels ?? CGPoint(
            x: (capturedImage?.size.width ?? 0) / 2,
            y: (capturedImage?.size.height ?? 0) / 2
        )

        // Convert to inches from POA
        // Note: Image Y increases downward, but we want Y positive = up
        let xInches = (pixelPosition.x - poa.x) / ppi
        let yInches = (poa.y - pixelPosition.y) / ppi  // Inverted for cartesian

        return HolePosition(
            x: Decimal(Double(xInches)),
            y: Decimal(Double(yInches))
        )
    }

    /// Get all holes in inches relative to POA
    func getHolePositionsInInches() -> [HolePosition] {
        holeMarkersPixels.compactMap { pixelsToInches($0) }
    }

    // MARK: - Metrics Calculation

    func calculateMetrics() async {
        isLoading = true
        error = nil

        do {
            let holePositions = getHolePositionsInInches()

            guard holePositions.count >= 2 else {
                throw MeasurementError.insufficientHoles
            }

            let request = CreateGroupMeasurementRequest(
                holePositions: holePositions,
                bulletDiameter: bulletDiameter,
                calibrationMethod: .manual
            )

            // Call API to calculate (don't save yet - just preview)
            // For MVP, we save directly and use the response
            // Future: Could add a preview-only endpoint

            let measurement = try await measurementService.createMeasurement(
                groupId: groupId,
                request: request
            )

            calculatedMeasurement = measurement
            generateAnnotatedImage()

        } catch {
            self.error = error.localizedDescription
            showError = true
        }

        isLoading = false
    }

    // MARK: - Save

    func save() async -> Bool {
        // Measurement already saved in calculateMetrics for MVP
        // This just indicates success
        return calculatedMeasurement != nil
    }

    // MARK: - Annotated Image Generation

    private func generateAnnotatedImage() {
        guard let image = capturedImage else { return }

        let renderer = UIGraphicsImageRenderer(size: image.size)

        annotatedImage = renderer.image { context in
            // Draw original image
            image.draw(at: .zero)

            let ctx = context.cgContext

            // Draw POA crosshair
            if let poa = poaPositionPixels {
                ctx.setStrokeColor(UIColor.red.cgColor)
                ctx.setLineWidth(3)

                // Horizontal line
                ctx.move(to: CGPoint(x: poa.x - 30, y: poa.y))
                ctx.addLine(to: CGPoint(x: poa.x + 30, y: poa.y))

                // Vertical line
                ctx.move(to: CGPoint(x: poa.x, y: poa.y - 30))
                ctx.addLine(to: CGPoint(x: poa.x, y: poa.y + 30))

                ctx.strokePath()
            }

            // Draw hole markers
            for (index, position) in holeMarkersPixels.enumerated() {
                // Circle
                ctx.setStrokeColor(UIColor.systemGreen.cgColor)
                ctx.setFillColor(UIColor.systemGreen.withAlphaComponent(0.3).cgColor)
                ctx.setLineWidth(2)

                let radius: CGFloat = 20
                let rect = CGRect(
                    x: position.x - radius,
                    y: position.y - radius,
                    width: radius * 2,
                    height: radius * 2
                )
                ctx.fillEllipse(in: rect)
                ctx.strokeEllipse(in: rect)

                // Number label
                let label = "\(index + 1)"
                let attrs: [NSAttributedString.Key: Any] = [
                    .font: UIFont.boldSystemFont(ofSize: 16),
                    .foregroundColor: UIColor.white
                ]
                let size = label.size(withAttributes: attrs)
                let labelPoint = CGPoint(
                    x: position.x - size.width / 2,
                    y: position.y - size.height / 2
                )
                label.draw(at: labelPoint, withAttributes: attrs)
            }
        }
    }

    // MARK: - Errors

    enum MeasurementError: LocalizedError {
        case insufficientHoles
        case calibrationRequired
        case imageRequired

        var errorDescription: String? {
            switch self {
            case .insufficientHoles:
                return "At least 2 holes are required"
            case .calibrationRequired:
                return "Calibration is required"
            case .imageRequired:
                return "Please capture or select an image"
            }
        }
    }
}
```

---

## 7. Views

### 7.1 Main Flow Container

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Views/GroupMeasurementFlow.swift`

```swift
import SwiftUI

struct GroupMeasurementFlow: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel: GroupMeasurementViewModel

    let onComplete: (GroupMeasurement) -> Void

    init(
        groupId: Int,
        distance: Int,
        existingMeasurement: GroupMeasurement? = nil,
        onComplete: @escaping (GroupMeasurement) -> Void
    ) {
        _viewModel = StateObject(wrappedValue: GroupMeasurementViewModel(
            groupId: groupId,
            distance: distance,
            existingMeasurement: existingMeasurement
        ))
        self.onComplete = onComplete
    }

    var body: some View {
        NavigationStack {
            Group {
                switch viewModel.currentStep {
                case .capture:
                    CaptureStepView(viewModel: viewModel)
                case .calibration:
                    CalibrationStepView(viewModel: viewModel)
                case .markHoles:
                    HoleMarkingView(viewModel: viewModel)
                case .metadata:
                    MeasurementMetadataView(viewModel: viewModel)
                case .review:
                    MeasurementReviewView(viewModel: viewModel) {
                        if let measurement = viewModel.calculatedMeasurement {
                            onComplete(measurement)
                        }
                        dismiss()
                    }
                }
            }
            .navigationTitle(navigationTitle)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }

                if viewModel.currentStep != .capture {
                    ToolbarItem(placement: .navigationBarLeading) {
                        Button {
                            viewModel.goToPreviousStep()
                        } label: {
                            HStack(spacing: 4) {
                                Image(systemName: "chevron.left")
                                Text("Back")
                            }
                        }
                    }
                }
            }
            .alert("Error", isPresented: $viewModel.showError) {
                Button("OK") { }
            } message: {
                Text(viewModel.error ?? "An error occurred")
            }
        }
    }

    private var navigationTitle: String {
        switch viewModel.currentStep {
        case .capture: return "Capture Target"
        case .calibration: return "Calibrate"
        case .markHoles: return "Mark Holes"
        case .metadata: return "Details"
        case .review: return "Review"
        }
    }
}
```

### 7.2 Capture Step

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Views/CaptureStepView.swift`

```swift
import SwiftUI

struct CaptureStepView: View {
    @ObservedObject var viewModel: GroupMeasurementViewModel

    @State private var showingImageSourcePicker = false
    @State private var selectedImageSource: ImageSourceType?
    @State private var showingImagePicker = false

    var body: some View {
        VStack(spacing: 24) {
            Spacer()

            // Instructions
            VStack(spacing: 12) {
                Image(systemName: "camera.viewfinder")
                    .font(.system(size: 60))
                    .foregroundColor(.accentColor)

                Text("Photograph Your Target")
                    .font(.title2)
                    .fontWeight(.semibold)

                Text("Take a clear photo of your target, or select one from your photo library.")
                    .font(.body)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
            }

            // Tips
            VStack(alignment: .leading, spacing: 8) {
                TipRow(icon: "sun.max", text: "Good lighting helps accuracy")
                TipRow(icon: "arrow.up.left.and.arrow.down.right", text: "Include the full target in frame")
                TipRow(icon: "hand.raised", text: "Hold steady to avoid blur")
            }
            .padding()
            .background(Color(.systemGray6))
            .cornerRadius(12)
            .padding(.horizontal)

            Spacer()

            // Capture Button
            Button {
                showingImageSourcePicker = true
            } label: {
                Label("Select Photo", systemImage: "photo.on.rectangle")
                    .font(.headline)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.accentColor)
                    .foregroundColor(.white)
                    .cornerRadius(12)
            }
            .padding(.horizontal)
            .padding(.bottom)
        }
        .confirmationDialog("Select Photo", isPresented: $showingImageSourcePicker) {
            if ImageSourceType.camera.isAvailable {
                Button(ImageSourceType.camera.title) {
                    selectedImageSource = .camera
                    showingImagePicker = true
                }
            }
            Button(ImageSourceType.photoLibrary.title) {
                selectedImageSource = .photoLibrary
                showingImagePicker = true
            }
        }
        .sheet(isPresented: $showingImagePicker) {
            if selectedImageSource == .camera {
                ImagePicker(selectedImage: $viewModel.capturedImage, sourceType: .camera)
            } else {
                PhotoLibraryPicker(selectedImage: $viewModel.capturedImage)
            }
        }
        .onChange(of: viewModel.capturedImage) { _, newImage in
            if newImage != nil {
                viewModel.goToNextStep()
            }
        }
    }
}

struct TipRow: View {
    let icon: String
    let text: String

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .foregroundColor(.accentColor)
                .frame(width: 24)
            Text(text)
                .font(.subheadline)
            Spacer()
        }
    }
}
```

### 7.3 Calibration Step

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Views/CalibrationStepView.swift`

```swift
import SwiftUI

struct CalibrationStepView: View {
    @ObservedObject var viewModel: GroupMeasurementViewModel

    var body: some View {
        VStack(spacing: 0) {
            // Instructions banner
            InstructionBanner(
                text: instructionText,
                style: instructionStyle
            )

            // Image with calibration overlay
            ZoomableImageView(image: viewModel.capturedImage) { geometry in
                // Calibration point 1
                if let p1 = viewModel.calibrationPoint1 {
                    CalibrationMarker(position: p1, label: "1")
                }

                // Calibration point 2
                if let p2 = viewModel.calibrationPoint2 {
                    CalibrationMarker(position: p2, label: "2")
                }

                // Line between points
                if let p1 = viewModel.calibrationPoint1,
                   let p2 = viewModel.calibrationPoint2 {
                    CalibrationLine(from: p1, to: p2)
                }
            } onTap: { location in
                handleTap(at: location)
            }

            // Bottom controls
            VStack(spacing: 16) {
                // Reference distance input
                HStack {
                    Text("Reference Distance:")
                    Spacer()
                    TextField("1.0", value: $viewModel.referenceDistanceInches, format: .number)
                        .keyboardType(.decimalPad)
                        .textFieldStyle(.roundedBorder)
                        .frame(width: 80)
                    Text("inches")
                        .foregroundColor(.secondary)
                }

                // Pixels per inch display
                if let ppi = viewModel.pixelsPerInch {
                    HStack {
                        Text("Calibration:")
                        Spacer()
                        Text(String(format: "%.1f px/inch", ppi))
                            .foregroundColor(.green)
                    }
                    .font(.subheadline)
                }

                // Actions
                HStack(spacing: 16) {
                    Button("Reset") {
                        viewModel.resetCalibration()
                    }
                    .buttonStyle(.bordered)

                    Spacer()

                    Button("Continue") {
                        viewModel.goToNextStep()
                    }
                    .buttonStyle(.borderedProminent)
                    .disabled(!viewModel.canProceedFromCalibration)
                }
            }
            .padding()
            .background(Color(.systemBackground))
        }
        .onChange(of: viewModel.calibrationPoint2) { _, _ in
            viewModel.calculatePixelsPerInch()
        }
        .onChange(of: viewModel.referenceDistanceInches) { _, _ in
            viewModel.calculatePixelsPerInch()
        }
    }

    private var instructionText: String {
        if viewModel.calibrationPoint1 == nil {
            return "Tap the first point of a known distance"
        } else if viewModel.calibrationPoint2 == nil {
            return "Tap the second point"
        } else {
            return "Calibration set. Adjust reference distance if needed."
        }
    }

    private var instructionStyle: InstructionBanner.Style {
        if viewModel.canProceedFromCalibration {
            return .success
        } else {
            return .info
        }
    }

    private func handleTap(at location: CGPoint) {
        if viewModel.calibrationPoint1 == nil {
            viewModel.calibrationPoint1 = location
        } else if viewModel.calibrationPoint2 == nil {
            viewModel.calibrationPoint2 = location
        } else {
            // Reset and start over
            viewModel.resetCalibration()
            viewModel.calibrationPoint1 = location
        }
    }
}

struct InstructionBanner: View {
    let text: String
    var style: Style = .info

    enum Style {
        case info, success, warning

        var backgroundColor: Color {
            switch self {
            case .info: return Color.blue.opacity(0.1)
            case .success: return Color.green.opacity(0.1)
            case .warning: return Color.orange.opacity(0.1)
            }
        }

        var foregroundColor: Color {
            switch self {
            case .info: return .blue
            case .success: return .green
            case .warning: return .orange
            }
        }
    }

    var body: some View {
        Text(text)
            .font(.subheadline)
            .foregroundColor(style.foregroundColor)
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .padding(.horizontal)
            .background(style.backgroundColor)
    }
}

struct CalibrationMarker: View {
    let position: CGPoint
    let label: String

    var body: some View {
        ZStack {
            Circle()
                .fill(Color.blue)
                .frame(width: 24, height: 24)

            Text(label)
                .font(.caption)
                .fontWeight(.bold)
                .foregroundColor(.white)
        }
        .position(position)
    }
}

struct CalibrationLine: View {
    let from: CGPoint
    let to: CGPoint

    var body: some View {
        Path { path in
            path.move(to: from)
            path.addLine(to: to)
        }
        .stroke(Color.blue, style: StrokeStyle(lineWidth: 2, dash: [5, 5]))
    }
}
```

### 7.4 Hole Marking View

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Views/HoleMarkingView.swift`

```swift
import SwiftUI

struct HoleMarkingView: View {
    @ObservedObject var viewModel: GroupMeasurementViewModel

    var body: some View {
        VStack(spacing: 0) {
            // Instructions banner
            InstructionBanner(
                text: viewModel.isSettingPOA
                    ? "Tap to set Point of Aim (POA)"
                    : "Tap to mark hole centers. Long-press to select and drag.",
                style: viewModel.canProceedFromHoleMarking ? .success : .info
            )

            // Image with hole overlays
            ZoomableImageView(image: viewModel.capturedImage) { geometry in
                // POA marker
                if let poa = viewModel.poaPositionPixels {
                    POAMarker(position: poa)
                }

                // Hole markers
                ForEach(Array(viewModel.holeMarkersPixels.enumerated()), id: \.offset) { index, position in
                    HoleMarker(
                        position: position,
                        number: index + 1,
                        isSelected: viewModel.selectedHoleIndex == index
                    )
                    .onTapGesture {
                        if viewModel.selectedHoleIndex == index {
                            viewModel.selectedHoleIndex = nil
                        } else {
                            viewModel.selectedHoleIndex = index
                        }
                    }
                    .gesture(
                        DragGesture()
                            .onChanged { value in
                                viewModel.updateHolePosition(at: index, to: value.location)
                            }
                    )
                }
            } onTap: { location in
                if viewModel.isSettingPOA {
                    viewModel.setPOA(at: location)
                } else {
                    viewModel.addHole(at: location)
                }
            }

            // Bottom toolbar
            VStack(spacing: 12) {
                // Hole count and POA toggle
                HStack {
                    Text("\(viewModel.holeCount) holes")
                        .font(.subheadline)

                    Spacer()

                    // POA button
                    Button {
                        viewModel.isSettingPOA.toggle()
                    } label: {
                        Label(
                            viewModel.isSettingPOA ? "Setting POA..." : "Set POA",
                            systemImage: "scope"
                        )
                    }
                    .buttonStyle(.bordered)
                    .tint(viewModel.isSettingPOA ? .orange : .secondary)

                    // Delete button (when hole selected)
                    if viewModel.selectedHoleIndex != nil {
                        Button(role: .destructive) {
                            viewModel.removeSelectedHole()
                        } label: {
                            Label("Remove", systemImage: "trash")
                        }
                        .buttonStyle(.bordered)
                    }
                }

                // Continue button
                Button("Continue") {
                    viewModel.goToNextStep()
                }
                .buttonStyle(.borderedProminent)
                .frame(maxWidth: .infinity)
                .disabled(!viewModel.canProceedFromHoleMarking)
            }
            .padding()
            .background(Color(.systemBackground))
        }
    }
}
```

### 7.5 Components

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Components/ZoomableImageView.swift`

```swift
import SwiftUI

struct ZoomableImageView<Overlay: View>: View {
    let image: UIImage?
    let overlay: (GeometryProxy) -> Overlay
    let onTap: ((CGPoint) -> Void)?

    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @State private var lastOffset: CGSize = .zero

    init(
        image: UIImage?,
        @ViewBuilder overlay: @escaping (GeometryProxy) -> Overlay,
        onTap: ((CGPoint) -> Void)? = nil
    ) {
        self.image = image
        self.overlay = overlay
        self.onTap = onTap
    }

    var body: some View {
        GeometryReader { geometry in
            if let uiImage = image {
                let imageSize = uiImage.size
                let aspectRatio = imageSize.width / imageSize.height
                let containerSize = geometry.size

                // Calculate fitted size
                let fittedSize: CGSize
                if containerSize.width / containerSize.height > aspectRatio {
                    fittedSize = CGSize(
                        width: containerSize.height * aspectRatio,
                        height: containerSize.height
                    )
                } else {
                    fittedSize = CGSize(
                        width: containerSize.width,
                        height: containerSize.width / aspectRatio
                    )
                }

                let imageScale = fittedSize.width / imageSize.width

                ZStack {
                    Image(uiImage: uiImage)
                        .resizable()
                        .aspectRatio(contentMode: .fit)

                    // Overlay scaled to match image
                    overlay(geometry)
                        .scaleEffect(imageScale)
                        .frame(width: imageSize.width, height: imageSize.height)
                        .scaleEffect(1 / imageScale)
                }
                .scaleEffect(scale)
                .offset(offset)
                .gesture(
                    MagnificationGesture()
                        .onChanged { value in
                            scale = lastScale * value
                        }
                        .onEnded { _ in
                            lastScale = scale
                            if scale < 1.0 {
                                withAnimation {
                                    scale = 1.0
                                    lastScale = 1.0
                                }
                            }
                        }
                )
                .gesture(
                    DragGesture()
                        .onChanged { value in
                            offset = CGSize(
                                width: lastOffset.width + value.translation.width,
                                height: lastOffset.height + value.translation.height
                            )
                        }
                        .onEnded { _ in
                            lastOffset = offset
                        }
                )
                .simultaneousGesture(
                    TapGesture()
                        .onEnded {
                            // This won't give us location - need different approach
                        }
                )
                .onTapGesture { location in
                    // Convert tap location to image coordinates
                    let imageLocation = convertToImageCoordinates(
                        tapLocation: location,
                        containerSize: containerSize,
                        fittedSize: fittedSize,
                        imageSize: imageSize
                    )
                    onTap?(imageLocation)
                }
                .frame(width: containerSize.width, height: containerSize.height)
            } else {
                Color.gray.opacity(0.2)
                    .overlay(
                        Text("No Image")
                            .foregroundColor(.secondary)
                    )
            }
        }
        .clipped()
    }

    private func convertToImageCoordinates(
        tapLocation: CGPoint,
        containerSize: CGSize,
        fittedSize: CGSize,
        imageSize: CGSize
    ) -> CGPoint {
        // Account for centering
        let xOffset = (containerSize.width - fittedSize.width) / 2
        let yOffset = (containerSize.height - fittedSize.height) / 2

        // Account for zoom and pan
        let adjustedX = (tapLocation.x - xOffset - offset.width) / scale
        let adjustedY = (tapLocation.y - yOffset - offset.height) / scale

        // Convert to image coordinates
        let imageX = adjustedX * (imageSize.width / fittedSize.width)
        let imageY = adjustedY * (imageSize.height / fittedSize.height)

        return CGPoint(x: imageX, y: imageY)
    }
}
```

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Components/HoleMarker.swift`

```swift
import SwiftUI

struct HoleMarker: View {
    let position: CGPoint
    let number: Int
    var isSelected: Bool = false

    var body: some View {
        ZStack {
            // Outer ring (selection indicator)
            if isSelected {
                Circle()
                    .stroke(Color.blue, lineWidth: 3)
                    .frame(width: 40, height: 40)
            }

            // Main circle
            Circle()
                .fill(Color.green.opacity(0.3))
                .frame(width: 30, height: 30)

            Circle()
                .stroke(Color.green, lineWidth: 2)
                .frame(width: 30, height: 30)

            // Number
            Text("\(number)")
                .font(.caption)
                .fontWeight(.bold)
                .foregroundColor(.white)
        }
        .position(position)
    }
}
```

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Components/POAMarker.swift`

```swift
import SwiftUI

struct POAMarker: View {
    let position: CGPoint

    var body: some View {
        ZStack {
            // Crosshairs
            Rectangle()
                .fill(Color.red)
                .frame(width: 40, height: 3)

            Rectangle()
                .fill(Color.red)
                .frame(width: 3, height: 40)

            // Center dot
            Circle()
                .fill(Color.red)
                .frame(width: 8, height: 8)
        }
        .position(position)
    }
}
```

### 7.6 Metadata View

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Views/MeasurementMetadataView.swift`

```swift
import SwiftUI

struct MeasurementMetadataView: View {
    @ObservedObject var viewModel: GroupMeasurementViewModel

    var body: some View {
        Form {
            Section {
                // Common caliber picker
                Picker("Bullet Diameter", selection: $viewModel.selectedCommonDiameter) {
                    ForEach(CommonBulletDiameter.allCases, id: \.self) { caliber in
                        Text(caliber.displayName).tag(Optional(caliber))
                    }
                    Text("Custom").tag(nil as CommonBulletDiameter?)
                }
                .onChange(of: viewModel.selectedCommonDiameter) { _, newValue in
                    if let caliber = newValue {
                        viewModel.bulletDiameter = caliber.diameter
                        viewModel.useCustomDiameter = false
                    } else {
                        viewModel.useCustomDiameter = true
                    }
                }

                // Custom diameter input
                if viewModel.useCustomDiameter {
                    HStack {
                        Text("Custom Diameter")
                        Spacer()
                        TextField("0.308", value: $viewModel.bulletDiameter, format: .number)
                            .keyboardType(.decimalPad)
                            .textFieldStyle(.roundedBorder)
                            .frame(width: 80)
                        Text("\"")
                            .foregroundColor(.secondary)
                    }
                }
            } header: {
                Text("Bullet")
            } footer: {
                Text("Select the bullet diameter for accurate edge-to-edge group size calculation.")
            }

            Section {
                HStack {
                    Text("Distance")
                    Spacer()
                    Text("\(viewModel.distance) yards")
                        .foregroundColor(.secondary)
                }

                HStack {
                    Text("Shots")
                    Spacer()
                    Text("\(viewModel.holeCount)")
                        .foregroundColor(.secondary)
                }
            } header: {
                Text("Group Info")
            }

            Section {
                Button {
                    Task {
                        await viewModel.calculateMetrics()
                        if viewModel.calculatedMeasurement != nil {
                            viewModel.goToNextStep()
                        }
                    }
                } label: {
                    if viewModel.isLoading {
                        HStack {
                            ProgressView()
                            Text("Calculating...")
                        }
                        .frame(maxWidth: .infinity)
                    } else {
                        Text("Calculate & Save")
                            .frame(maxWidth: .infinity)
                    }
                }
                .buttonStyle(.borderedProminent)
                .disabled(viewModel.isLoading)
            }
        }
    }
}
```

### 7.7 Review View

**File:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Views/MeasurementReviewView.swift`

```swift
import SwiftUI

struct MeasurementReviewView: View {
    @ObservedObject var viewModel: GroupMeasurementViewModel
    let onDone: () -> Void

    @State private var showAdvancedMetrics = false

    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // Annotated image preview
                if let image = viewModel.annotatedImage {
                    Image(uiImage: image)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(maxHeight: 300)
                        .cornerRadius(12)
                        .shadow(radius: 4)
                }

                if let measurement = viewModel.calculatedMeasurement {
                    // Primary metrics
                    VStack(spacing: 16) {
                        MetricCard(
                            title: "Group Size (ES)",
                            primaryValue: measurement.formattedExtremeSpread ?? "--",
                            secondaryValue: measurement.formattedExtremeSpreadMoa
                        )

                        MetricCard(
                            title: "Mean Radius",
                            primaryValue: measurement.formattedMeanRadius ?? "--",
                            secondaryValue: measurement.formattedMeanRadiusMoa
                        )

                        HStack(spacing: 16) {
                            MetricCard(
                                title: "H Spread",
                                primaryValue: formatInches(measurement.horizontalSpread),
                                secondaryValue: nil
                            )

                            MetricCard(
                                title: "V Spread",
                                primaryValue: formatInches(measurement.verticalSpread),
                                secondaryValue: nil
                            )
                        }

                        // POI Offset
                        if let poiDesc = measurement.poiOffsetDescription {
                            MetricCard(
                                title: "POI Offset",
                                primaryValue: poiDesc,
                                secondaryValue: nil
                            )
                        }
                    }
                    .padding(.horizontal)

                    // Advanced metrics (collapsible)
                    DisclosureGroup("Advanced Metrics", isExpanded: $showAdvancedMetrics) {
                        VStack(spacing: 12) {
                            MetricRow(label: "CEP50", value: formatInches(measurement.cep50))
                            MetricRow(label: "Radial Std Dev", value: formatInches(measurement.radialStdDev))
                            MetricRow(label: "H Std Dev", value: formatInches(measurement.horizontalStdDev))
                            MetricRow(label: "V Std Dev", value: formatInches(measurement.verticalStdDev))
                        }
                        .padding(.top, 8)
                    }
                    .padding(.horizontal)

                    // Actions
                    VStack(spacing: 12) {
                        Button {
                            viewModel.goToStep(.markHoles)
                        } label: {
                            Label("Edit Holes", systemImage: "pencil")
                                .frame(maxWidth: .infinity)
                        }
                        .buttonStyle(.bordered)

                        Button {
                            onDone()
                        } label: {
                            Text("Done")
                                .frame(maxWidth: .infinity)
                        }
                        .buttonStyle(.borderedProminent)
                    }
                    .padding()
                }
            }
            .padding(.vertical)
        }
    }

    private func formatInches(_ value: Decimal?) -> String {
        guard let v = value else { return "--" }
        return String(format: "%.3f\"", NSDecimalNumber(decimal: v).doubleValue)
    }
}

struct MetricCard: View {
    let title: String
    let primaryValue: String
    let secondaryValue: String?

    var body: some View {
        VStack(spacing: 4) {
            Text(title)
                .font(.caption)
                .foregroundColor(.secondary)

            Text(primaryValue)
                .font(.title2)
                .fontWeight(.semibold)

            if let secondary = secondaryValue {
                Text(secondary)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
    }
}

struct MetricRow: View {
    let label: String
    let value: String

    var body: some View {
        HStack {
            Text(label)
                .foregroundColor(.secondary)
            Spacer()
            Text(value)
        }
        .font(.subheadline)
    }
}
```

---

## 8. Integration Points

### 8.1 Entry from SessionDetailView

Add a "Measure" button to GroupEntry cards:

```swift
// In GroupEntryCard or similar
Button {
    showingMeasurementFlow = true
} label: {
    Label("Measure", systemImage: "ruler")
}
.sheet(isPresented: $showingMeasurementFlow) {
    GroupMeasurementFlow(
        groupId: group.id,
        distance: group.distance,
        existingMeasurement: group.measurement
    ) { measurement in
        // Refresh session to show new measurement
        Task { await viewModel.refreshSession() }
    }
}
```

### 8.2 Update GroupEntry Model

Add measurement property to existing GroupEntry:

```swift
// In Models/GroupEntry.swift
struct GroupEntry: Codable, Identifiable {
    // ... existing properties ...

    let measurement: GroupMeasurement?  // ADD THIS
}
```

---

## 9. Testing Checklist

### UI/UX Testing
- [ ] Camera picker works on device
- [ ] Photo library picker works
- [ ] Pinch-to-zoom works smoothly
- [ ] Tap-to-mark adds holes at correct location
- [ ] Drag-to-adjust moves holes correctly
- [ ] POA marker can be set and moved
- [ ] Calibration line draws between points
- [ ] Calibration calculation updates live
- [ ] Bullet diameter picker works
- [ ] Metrics display correctly
- [ ] Annotated image shows all markers

### API Integration
- [ ] Create measurement succeeds
- [ ] Measurement displays in session detail
- [ ] Error handling shows user-friendly messages

### Edge Cases
- [ ] Cancel at any step dismisses properly
- [ ] Back navigation preserves state
- [ ] < 2 holes shows appropriate error
- [ ] Invalid calibration (0 distance) handled
- [ ] Large images don't cause memory issues

---

## 10. File Checklist

| File | Action |
|------|--------|
| `Models/GroupMeasurement.swift` | Create |
| `Core/Network/APIEndpoints.swift` | Update (add GroupMeasurements) |
| `Services/GroupMeasurementService.swift` | Create |
| `Features/GroupMeasurement/ViewModels/GroupMeasurementViewModel.swift` | Create |
| `Features/GroupMeasurement/Views/GroupMeasurementFlow.swift` | Create |
| `Features/GroupMeasurement/Views/CaptureStepView.swift` | Create |
| `Features/GroupMeasurement/Views/CalibrationStepView.swift` | Create |
| `Features/GroupMeasurement/Views/HoleMarkingView.swift` | Create |
| `Features/GroupMeasurement/Views/MeasurementMetadataView.swift` | Create |
| `Features/GroupMeasurement/Views/MeasurementReviewView.swift` | Create |
| `Features/GroupMeasurement/Components/ZoomableImageView.swift` | Create |
| `Features/GroupMeasurement/Components/HoleMarker.swift` | Create |
| `Features/GroupMeasurement/Components/POAMarker.swift` | Create |
| `Models/GroupEntry.swift` | Update (add measurement property) |
| Session detail views | Update (add Measure button) |

---

## Document History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-28 | 1.0 | Claude | Initial specification |
