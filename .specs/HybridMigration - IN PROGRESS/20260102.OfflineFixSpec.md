# Offline Functionality Fixes Specification

**Date:** 2026-01-02
**Status:** Phase 3 Complete - In Progress
**Phase:** 4 of HybridMigration
**Priority:** High
**Last Updated:** 2026-01-02 23:50

---

## Problem Summary

Two critical offline functionality issues have been identified:

### Issue 1: Measuring Tool - Cannot Establish Reference Range Offline

**Symptom:** When the app is closed, then reopened in airplane mode (no wifi), users cannot place calibration points to establish a reference range in the measuring tool.

**Root Cause:** The `GroupMeasurementViewModel` is the **online-only** version that requires API connectivity. It makes API calls during the `calculateMetrics()` function (lines 237-263). When offline, these calls fail silently or with errors, potentially blocking the workflow.

**Key Finding:** The app has TWO measurement view models:
1. `GroupMeasurementViewModel` - **Online version** (requires network for metrics calculation)
2. `OfflineGroupMeasurementViewModel` - **Offline version** (uses `LocalGroupMetricsCalculator`)

The issue is that the **wrong view model is being used when offline**. The calibration UI itself (tap handling, point storage) is purely local and should work, but if the view is using `GroupMeasurementViewModel`, there may be network-dependent initialization or validation logic blocking it.

### Issue 2: Dashboard Stuck on "Loading dashboard..."

**Symptom:** After closing the app while in airplane mode with no wifi, reopening shows "Loading dashboard..." indefinitely on the home page. Other pages have similar issues.

**Root Cause:** The `DashboardViewModel.loadDashboard()` method:
1. Makes parallel API calls to `analyticsService.getSummary()` and `sessionService.getRecentSessions()`
2. **Has no offline fallback** - it just catches the error and sets `self.error`
3. The loading state (`isLoading = true`) combined with `!hasLoadedInitialData` shows the loading spinner forever

**Code Evidence (DashboardViewModel.swift:93-116):**
```swift
func loadDashboard() async {
    isLoading = true
    error = nil

    do {
        async let summaryTask = analyticsService.getSummary()
        async let sessionsTask = sessionService.getRecentSessions(count: 5)

        summary = try await summaryTask
        recentSessions = try await sessionsTask
        hasLoadedInitialData = true
        // ... success case
    } catch {
        self.error = error.localizedDescription
        // NOTE: isLoading = false happens AFTER this block
        // BUT hasLoadedInitialData stays FALSE
    }

    isLoading = false
}
```

**The bug:** When offline:
- `isLoading` becomes `false` (good)
- `hasLoadedInitialData` stays `false` (bad - triggers loading view)
- `error` is set (should trigger error view, but condition is wrong)

**DashboardView.swift:91-102:**
```swift
@ViewBuilder
private var content: some View {
    if viewModel.isLoading && !viewModel.hasLoadedInitialData {
        LoadingView(message: "Loading dashboard...")  // <-- STUCK HERE
    } else if let error = viewModel.error, !viewModel.hasLoadedInitialData {
        ErrorView(message: error) { ... }
    } else {
        dashboardContent
    }
}
```

**Why it shows "Loading" forever:**
- After error: `isLoading = false`, `hasLoadedInitialData = false`
- Condition `isLoading && !hasLoadedInitialData` = `false && true` = `false`
- Condition `error != nil && !hasLoadedInitialData` = `true && true` = `true` - should show error!

Wait - the logic seems correct. Let me re-examine...

Actually, the issue might be that the network request **hangs** rather than failing quickly. When truly offline, network requests can hang waiting for timeout rather than failing immediately. This means:
- `isLoading = true` stays true
- The `await` never returns (or takes 60+ seconds)
- User sees "Loading dashboard..." indefinitely

---

## Technical Analysis

### What's Currently Implemented

| Component | Online Behavior | Offline Behavior | Gap |
|-----------|----------------|------------------|-----|
| **RiflesViewModel** | Fetch from API, cache | Load from cache | Working |
| **AmmunitionViewModel** | Fetch from API, cache | Load from cache | Working |
| **LocationsViewModel** | Fetch from API, cache | Load from cache | Working |
| **DashboardViewModel** | Fetch summary + sessions | **No fallback** | **BROKEN** |
| **GroupMeasurementViewModel** | API-based calculation | **No fallback** | **BROKEN** |
| **OfflineGroupMeasurementViewModel** | N/A | Local calculation | Exists but not used |

### Root Causes

1. **Dashboard has no cached data model**
   - `AnalyticsSummary` is never cached
   - Recent sessions are never cached
   - No offline fallback exists

2. **Network timeout issues**
   - URLSession default timeout is 60 seconds
   - Offline requests hang rather than fail fast
   - User experience is terrible (waiting 60s for timeout)

3. **Measuring tool routing issue**
   - When navigating to measure a group, the app needs to detect offline state
   - Use `OfflineGroupMeasurementViewModel` when offline
   - Use `GroupMeasurementViewModel` when online

4. **NetworkMonitor may not be checked early enough**
   - Views start loading before checking network state
   - Need to check network state BEFORE making API calls

---

## Proposed Solutions

### Phase 1: Fix Network Timeout & Fast-Fail (Priority: HIGH)

**Goal:** API calls should fail immediately when offline, not hang for 60 seconds.

**Changes:**

1. **Modify APIClient to check network before making requests**

```swift
// In APIClient.swift

func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T {
    // FAST FAIL: Check network before attempting request
    guard NetworkMonitor.shared.isConnected else {
        throw APIError.offline
    }

    // ... existing request logic
}
```

2. **Add `APIError.offline` case**

```swift
enum APIError: Error, LocalizedError {
    case offline
    // ... existing cases

    var errorDescription: String? {
        switch self {
        case .offline:
            return "You're offline. Please connect to the internet."
        // ... existing cases
        }
    }
}
```

**Impact:** All API calls fail instantly when offline instead of waiting for timeout.

---

### Phase 2: Fix Dashboard Offline Handling (Priority: HIGH)

**Goal:** Dashboard shows meaningful content when offline.

**Option A: Show Cached Summary + Pending Sessions (Recommended)**

When offline, show:
- Cached summary data (if available from last online session)
- Pending sessions from `OfflineSessionQueue`
- "Offline Mode" indicator

**Changes:**

1. **Add dashboard summary caching to `ReferenceDataCache`**

```swift
// Add to ReferenceDataCache.swift

private var summaryURL: URL { cacheDirectory.appendingPathComponent("dashboard_summary.json") }

func cacheSummary(_ summary: AnalyticsSummary) {
    saveToCache(summary, url: summaryURL)
    updateMetadata()
}

func loadCachedSummary() -> AnalyticsSummary? {
    loadFromCache(url: summaryURL)
}
```

2. **Update `DashboardViewModel.loadDashboard()`**

```swift
func loadDashboard() async {
    isLoading = true
    error = nil

    if NetworkMonitor.shared.isConnected {
        // Online path - existing behavior + caching
        do {
            async let summaryTask = analyticsService.getSummary()
            async let sessionsTask = sessionService.getRecentSessions(count: 5)

            summary = try await summaryTask
            recentSessions = try await sessionsTask
            hasLoadedInitialData = true
            isUsingCachedData = false

            // Cache for offline use
            if let summary = summary {
                ReferenceDataCache.shared.cacheSummary(summary)
            }
        } catch {
            // Online but failed - try cache as fallback
            await loadFromCache()
            if !hasLoadedInitialData {
                self.error = error.localizedDescription
            }
        }
    } else {
        // Offline path - load from cache
        await loadFromCache()
    }

    isLoading = false
}

private func loadFromCache() async {
    // Try to load cached summary
    if let cachedSummary = ReferenceDataCache.shared.loadCachedSummary() {
        summary = cachedSummary
        isUsingCachedData = true
    }

    // For recent sessions, show pending offline sessions
    let pendingSessions = OfflineSessionQueue.shared.pendingSessions
    recentSessions = pendingSessions.map { pending in
        SessionListItem(
            id: -pending.id.hashValue, // Negative ID indicates pending
            sessionDate: pending.sessionDate,
            // ... map other fields
            isPending: true
        )
    }

    // Mark as loaded if we have ANY data
    hasLoadedInitialData = summary != nil || !recentSessions.isEmpty
}
```

3. **Update `DashboardView` to show offline indicator**

```swift
private var dashboardContent: some View {
    ScrollView {
        VStack(spacing: 24) {
            // Offline indicator
            if viewModel.isUsingCachedData {
                OfflineBanner()
            }

            // ... existing content
        }
    }
}
```

**Option B: Show Minimal Offline Dashboard (Simpler)**

When offline with no cached data, show:
- "You're Offline" message
- Quick action to create a new session (still works offline)
- Link to pending sessions

This is simpler but provides less value than Option A.

---

### Phase 3: Fix Group Measurement Routing (Priority: HIGH)

**Goal:** Measuring tool works correctly when offline.

**Current State:**
- `GroupMeasurementView` uses `GroupMeasurementViewModel` (online)
- `OfflineGroupMeasurementViewModel` exists but may not be used properly

**Changes:**

1. **Create unified entry point that chooses correct view model**

The entry point for group measurement needs to check:
- Is this an online synced session? → Use `GroupMeasurementViewModel`
- Is this a pending offline session? → Use `OfflineGroupMeasurementViewModel`
- Is network unavailable? → Use `OfflineGroupMeasurementViewModel`

2. **Review how measurement views are launched**

Need to trace where `GroupMeasurementView` or `GroupMeasurementViewModel` is instantiated and ensure offline routing is correct.

3. **Potential issue: Calibration UI sharing**

Both view models use the same calibration logic. The calibration step should work identically in both. Need to verify that `CalibrationStepView` can work with either view model, or create a shared protocol.

---

### Phase 4: Add Offline Indicator to All Main Views (Priority: MEDIUM)

**Goal:** User always knows when they're offline.

**Changes:**

1. **Create `OfflineBanner` component** (may already exist per spec)

```swift
struct OfflineBanner: View {
    @ObservedObject var networkMonitor = NetworkMonitor.shared
    @ObservedObject var offlineQueue = OfflineSessionQueue.shared

    var body: some View {
        if !networkMonitor.isConnected {
            HStack {
                Image(systemName: "wifi.slash")
                Text("Offline Mode")
                Spacer()
                if offlineQueue.pendingCount > 0 {
                    Text("\(offlineQueue.pendingCount) pending")
                        .font(.caption)
                }
            }
            .padding(.horizontal)
            .padding(.vertical, 8)
            .background(Color.orange.opacity(0.9))
            .foregroundColor(.white)
        }
    }
}
```

2. **Add to all main tab views:**
- Dashboard
- Sessions
- Gear (Rifles/Ammo)
- Settings

---

## Implementation Tasks

### Task 1: Fast-Fail Network Checks ✅ COMPLETE
- [x] Add `APIError.offline` case
- [x] Add network check to `APIClient.performRequest()` and `upload()`
- [x] Disable `waitsForConnectivity` in URLSession config (was causing requests to hang)
- [x] Build verified successful

### Task 2: Dashboard Offline Support ✅ COMPLETE
- [x] Add `cacheSummary()` / `loadCachedSummary()` to `ReferenceDataCache`
- [x] Update `DashboardViewModel.loadDashboard()` with offline handling
- [x] Add `isUsingCachedData` property to `DashboardViewModel`
- [x] Add `OfflineBanner` to `DashboardView` when using cached data
- [ ] Test dashboard displays cached data when offline

### Task 2.5: Sync Completion Alert ✅ COMPLETE
- [x] Add `SyncResult` struct to track sync outcomes
- [x] Add `lastSyncResult` published property to `OfflineSessionQueue`
- [x] Add `.sessionsDidSync` notification posted on sync completion
- [x] Add `clearSyncResult()` method to clear after user dismissal
- [x] Add dismissible alert to `DashboardView` showing sync result
- [x] Auto-refresh dashboard after successful sync
- [x] Build verified successful

### Task 3: Group Measurement Offline Routing ✅ COMPLETE
- [x] Audit where `GroupMeasurementViewModel` is instantiated
- [x] Add network check to route to correct view model
- [x] Verify calibration UI works with both view models
- [ ] Test full measurement flow when offline (manual testing required)

**Implementation Summary:**
- Created `AdaptiveGroupMeasurementFlow.swift` that routes based on `NetworkMonitor.shared.isConnected`
- When **online**: Uses `GroupMeasurementFlow` with API-based metrics calculation
- When **offline**: Shows "Offline Mode" message explaining that synced sessions require network
  - Synced sessions can't be measured offline because the API call to create/update measurement would fail
  - Users are guided to create offline sessions instead, which use local calculation
- Updated `SessionDetailView` to use `AdaptiveGroupMeasurementFlow` and `AdaptiveQuickMeasureFlow`
- Build verified successful


######
######
######
### Task 3.5 - DETOUR TO 20250103.UnifiedGroupMeasurementTool.md
######
######
######

### Task 4: Offline Indicators
- [ ] Create or update `OfflineBanner` component
- [ ] Add to `DashboardView`
- [ ] Add to `SessionsListView`
- [ ] Add to `GearTabView` (Rifles/Ammo)
- [ ] Test indicators appear when offline

### Task 5: Testing
- [ ] Test app cold start in airplane mode
- [ ] Test creating session while offline
- [ ] Test measuring group while offline
- [ ] Test sync when coming back online
- [ ] Test error handling when going offline mid-operation

---

## Testing Scenarios

### Scenario 1: Cold Start Offline
1. Close app completely
2. Enable airplane mode, disable WiFi
3. Open app
4. **Expected:** Dashboard shows cached summary (if available) or "Offline" message with quick actions
5. **Expected:** Can create new session, add DOPE/chrono/groups
6. **Expected:** Can measure groups using local calculator

### Scenario 2: Go Offline Mid-Session
1. Start app online
2. Create new session
3. Go offline
4. Continue adding data
5. **Expected:** Data saved to pending queue
6. **Expected:** Offline indicator appears

### Scenario 3: Measure Group Offline
1. Start offline
2. Create pending session
3. Add group entry
4. Launch measuring tool
5. Tap to set calibration points
6. **Expected:** Calibration points register correctly
7. Mark holes
8. **Expected:** Local metrics calculated and displayed

### Scenario 4: Return Online
1. Complete offline session
2. Re-enable connectivity
3. **Expected:** Auto-sync triggered
4. **Expected:** Pending session synced to server
5. **Expected:** Dashboard refreshes with live data

---

## Files to Modify

| File | Changes |
|------|---------|
| `Core/Network/APIClient.swift` | Add offline check, `APIError.offline` |
| `Core/Services/ReferenceDataCache.swift` | Add summary caching |
| `ViewModels/DashboardViewModel.swift` | Add offline fallback |
| `Features/Dashboard/DashboardView.swift` | Add offline indicator |
| `Features/GroupMeasurement/*/` | Verify routing |
| `Components/OfflineBanner.swift` | Create if not exists |

---

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Cached summary becomes stale | Show "Last updated X" timestamp |
| User confused about pending vs synced | Clear visual distinction |
| Network check false positive | Use NWPathMonitor, already implemented |
| Large pending queue | Show warning if many items pending |

---

## Success Criteria

1. App opens to usable state when offline (no infinite loading)
2. Measuring tool calibration works offline
3. All offline data syncs successfully when back online
4. User always knows when they're offline

---

## Next Steps

1. Review and approve this specification
2. Implement Phase 1 (fast-fail network checks) - highest impact, lowest effort
3. Implement Phase 2 (dashboard offline) - fixes the immediate user-facing bug
4. Implement Phase 3 (measurement routing) - fixes calibration issue
5. Implement Phase 4 (offline indicators) - polish

Ready to proceed when approved.
