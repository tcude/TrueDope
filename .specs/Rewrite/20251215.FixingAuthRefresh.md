# Fixing Auth Token Refresh Issues

**Date**: 2025-12-15
**Status**: Implemented
**Priority**: High (impacts active usage)

## Problem Statement

Users are experiencing unexpected logouts while actively using the application. This disrupts workflow during heavy data entry sessions (e.g., chrono session velocity readings).

Additionally, users were experiencing 429 (Too Many Requests) errors followed by 500 (Internal Server Error) during rapid data entry.

## Root Cause Analysis

### Issue 1: Short Token Lifetime

**Original Configuration:**
- **Access token lifetime**: 15 minutes ([JwtSettings.cs:10](../backend/src/TrueDope.Api/Configuration/JwtSettings.cs#L10))
- **Refresh token lifetime**: 7 days ([JwtSettings.cs:11](../backend/src/TrueDope.Api/Configuration/JwtSettings.cs#L11))
- **Refresh mechanism**: Reactive only (triggers after 401 response)

**Failure Points Identified:**

1. **Short token lifetime**: 15 minutes is aggressive for a data entry application. Users stepping away briefly or network delays can cause expiration mid-session.

2. **Reactive-only refresh**: The frontend only attempts token refresh after receiving a 401. This means:
   - Request fails first
   - Then refresh is attempted
   - Any issues during refresh → logout

3. **Redis dependency**: Refresh tokens stored in Redis ([JwtService.cs:77-95](../backend/src/TrueDope.Api/Services/JwtService.cs#L77-L95)). Redis restarts or memory pressure causes token loss.

4. **Token rotation race condition**: Each refresh invalidates the old token and issues a new one ([AuthController.cs:260-268](../backend/src/TrueDope.Api/Controllers/AuthController.cs#L260-L268)). Concurrent requests during refresh can cause issues.

### Issue 2: Rate Limiting Misconfiguration (Critical Finding)

**Symptoms:** Users hitting 429 errors with only ~30 requests, followed by 500 errors on subsequent requests.

**Root Cause:** The rate limiting middleware runs **before** authentication in the middleware pipeline ([Program.cs:236-245](../backend/src/TrueDope.Api/Program.cs#L236-L245)), so `context.User` is always empty when rate limits are checked.

**Middleware Order:**
1. CORS
2. Exception Handling
3. Security Headers
4. **Rate Limiting** ← `context.User` is NOT populated yet
5. Serilog
6. **Authentication** ← `context.User` gets populated here
7. Authorization
8. Controllers

**Result:** The rate limiting code ([RateLimitingMiddleware.cs:137-145](../backend/src/TrueDope.Api/Middleware/RateLimitingMiddleware.cs#L137-L145)) checks for a user ID:

```csharp
var userId = context.User.FindFirstValue(ClaimTypes.NameIdentifier);

if (!string.IsNullOrEmpty(userId))
{
    return ($"api:user:{userId}", _options.ApiRequestsPerMinutePerUser, 60);  // 300/min
}

// Unauthenticated API requests - by IP
return ($"api:ip:{clientIp}", _options.ApiRequestsPerMinutePerIp, 60);  // Was 30/min!
```

Since `context.User` is always empty at this point, **ALL authenticated requests were hitting the IP-based limit of 30/minute** instead of the intended user-based limit of 300/minute.

**Log Evidence:**
```
Rate limit exceeded for api:ip:::ffff:169.197.141.10 on /api/sessions/29. Count: 31, Limit: 30
```

### Issue 3: Cascading Failures from Rate Limiting

When users hit the 429 rate limit:
1. Frontend doesn't receive the response from successful requests
2. UI state becomes stale (e.g., velocity count doesn't update)
3. User retries → shot numbers are calculated from stale state
4. Database unique constraint violation on `(ChronoSessionId, ShotNumber)` → 500 error

## Solution Implementation

### Phase 1: Token Lifetime Extension

**File**: [JwtSettings.cs](../backend/src/TrueDope.Api/Configuration/JwtSettings.cs)

Changed `AccessTokenExpirationMinutes` from 15 to 60 minutes.

**Rationale:**
- 60 minutes is industry standard for low-to-medium security web applications
- Matches SaaS apps like Notion, Linear, Figma
- Balances security (still rotates tokens hourly) with UX (uninterrupted work sessions)

### Phase 2: Proactive Token Refresh

**File**: [api.ts](../frontend/src/services/api.ts)

Implemented proactive token refresh that:
- Decodes JWT to extract expiration time
- Stores expiration in localStorage for persistence
- Refreshes tokens 5 minutes before expiration
- Prevents multiple simultaneous refresh attempts
- Falls back to reactive refresh if proactive fails

Key additions:
- `getTokenExpiration()` - Decodes JWT payload to get `exp` claim
- `shouldRefreshToken()` - Checks if within 5-minute refresh buffer
- `isTokenExpired()` - Checks if token is fully expired
- `proactiveRefresh()` - Performs refresh before expiration
- Request interceptor triggers proactive refresh on each API call

### Phase 3: Error Handling & User Feedback

**File**: [AuthEventHandler.tsx](../frontend/src/components/AuthEventHandler.tsx) (new)

Created component that:
- Listens for `auth:logout` custom events dispatched by api.ts
- Shows toast notifications explaining logout reason
- Provides user-friendly messages for different failure scenarios

**File**: [App.tsx](../frontend/src/App.tsx)

Integrated `AuthEventHandler` into the app inside `ToastProvider`.

### Phase 4: Rate Limiting Fix (Critical)

**File**: [Program.cs](../backend/src/TrueDope.Api/Program.cs)

Changed `ApiRequestsPerMinutePerIp` from 30 to 300:

```csharp
app.UseRateLimiting(options =>
{
    options.LoginAttemptsPerMinute = 5;
    options.RegistrationsPerHour = 3;
    options.PasswordResetsPerHour = 3;
    options.AuthRequestsPerMinute = 20;
    options.ApiRequestsPerMinutePerUser = 300;
    options.ApiRequestsPerMinutePerIp = 300;  // Was 30!
});
```

**Why not move rate limiting after auth?**
The rate limiting middleware is intentionally placed before authentication to rate-limit login attempts by IP (preventing brute force attacks). Moving it after auth would break this protection.

**Alternative Future Solution:**
Implement a two-phase rate limiting approach:
1. Auth endpoints: Rate limit by IP (before auth middleware)
2. API endpoints: Rate limit by user (after auth middleware)

This would require splitting the middleware or using ASP.NET Core's built-in rate limiting with endpoint-specific policies.

## Implementation Checklist

### Phase 1: Token Lifetime Extension
- [x] Update `AccessTokenExpirationMinutes` from 15 to 60
- [x] Restart backend service
- [ ] Verify tokens are issued with 60-minute expiration

### Phase 2: Proactive Refresh
- [x] Implement proactive refresh in frontend
- [x] Add token expiration decoding (JWT payload parsing)
- [x] Add refresh buffer logic (5 min before expiration)
- [x] Handle concurrent request scenarios
- [x] Add debug logging for refresh operations

### Phase 3: Error Handling
- [x] Add AuthEventHandler component for toast notifications
- [x] Dispatch custom events on auth failures
- [x] Show user-friendly messages on session expiry

### Phase 4: Rate Limiting Fix
- [x] Identify that IP-based rate limiting was being used for all requests
- [x] Bump `ApiRequestsPerMinutePerIp` from 30 to 300
- [x] Rebuild and restart backend container
- [ ] Verify no more 429 errors during normal use

## Testing

### Token Refresh Verification
1. Login and verify token expiration in JWT payload (should show ~60 min from now)
2. Use application for extended period without logout
3. Verify refresh still works after 60 minutes
4. Check browser console for `[Auth]` debug messages during proactive refresh

### Rate Limiting Verification
1. Perform rapid data entry (add 30+ velocity readings quickly)
2. Verify no 429 errors occur
3. Check backend logs: should NOT see "Rate limit exceeded for api:ip:..."

## Rollback Plan

**Token changes:** Revert `AccessTokenExpirationMinutes` to 15 and restart backend.

**Rate limiting:** Revert `ApiRequestsPerMinutePerIp` to 30 (not recommended - will reintroduce 429 issues).

## Security Considerations

- 60-minute access tokens are still considered secure for non-financial applications
- Refresh token rotation remains in place (single-use refresh tokens)
- Redis-based refresh token storage allows for immediate revocation if needed
- Rate limiting still protects against abuse (300 req/min is reasonable for legitimate use)
- Auth endpoints maintain stricter limits (5 login attempts/min, 3 registrations/hour)

## Future Improvements

1. **Two-phase rate limiting**: Implement separate rate limiting for auth (by IP, before auth middleware) and API (by user, after auth middleware) endpoints
2. **Refresh token family tracking**: Detect token theft by tracking refresh token lineage
3. **Batch velocity readings**: Reduce API calls by batching multiple readings in a single request
4. **Server-side shot number assignment**: Auto-assign shot numbers on the server to prevent race conditions during rapid entry
