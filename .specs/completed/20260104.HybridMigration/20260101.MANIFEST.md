# TrueDope iOS Offline Session Recording - Specification Manifest

**Document Version:** 2.0
**Date:** 2026-01-01
**Status:** Draft - Awaiting Review
**Goal:** Enable TrueDope iOS to **create and record sessions** (DOPE, chrono, groups with measurements) entirely offline, with automatic sync when connectivity returns.

---

## Table of Contents
1. [Executive Summary](#executive-summary)
2. [Scope Definition](#scope-definition)
3. [Current State Analysis](#current-state-analysis)
4. [Architecture Proposal](#architecture-proposal)
5. [Data Models](#data-models)
6. [UI/UX Changes](#uiux-changes)
7. [Implementation Phases](#implementation-phases)
8. [Risk Assessment](#risk-assessment)
9. [Future Enhancements](#future-enhancements)

---

## Executive Summary

### The Problem

The TrueDope iOS app currently requires constant internet connectivity to function. This is problematic because:

1. **Range locations often lack cell service** - Rural ranges, wilderness areas, and even some indoor facilities have poor or no connectivity
2. **Users can't record data in real-time** - Must wait until back in service area or manually track data on paper
3. **The core use case (recording at the range) is broken** when there's no signal

### The Solution

Implement an **offline session queue** where:

1. Users can **create new sessions** and record all data types (DOPE, chrono, groups) without connectivity
2. Data is **stored locally** until connectivity returns
3. **Automatic sync** pushes queued sessions to the server when online
4. Clear UI indicates offline status and pending sync items

### What This Does NOT Include (Intentionally)

- Viewing historical sessions offline (still requires network)
- Editing previously-synced sessions offline (still requires network)
- Complex conflict resolution (create-only = no conflicts possible)

### Impact Assessment

| Aspect | Current State | After Implementation |
|--------|---------------|---------------------|
| Create new session offline | Impossible | Fully functional |
| Add DOPE entries offline | Impossible | Fully functional |
| Add chrono data offline | Impossible | Fully functional |
| Add groups + measurements offline | Impossible | Fully functional |
| Capture images offline | Impossible | Queued for upload |
| View past sessions offline | Impossible | **Still requires network** |
| Edit synced sessions offline | Impossible | **Still requires network** |

---

## Scope Definition

### In Scope (MVP)

| Feature | Description |
|---------|-------------|
| **Offline session creation** | Start a new session without network |
| **Offline DOPE entry** | Add distance holds to the session |
| **Offline chrono recording** | Add chrono sessions with velocity readings |
| **Offline group entry** | Add groups with shot count, size, notes |
| **Offline group measurement** | Capture target photos, mark holes, calculate metrics |
| **Offline image capture** | Store images locally, queue for upload |
| **Automatic sync** | Push all queued data when connectivity returns |
| **Offline indicator** | Banner showing "Offline Mode - Data will sync when connected" |
| **Pending sync badge** | Show count of sessions awaiting sync |

### Out of Scope (Future Enhancement)

| Feature | Reason |
|---------|--------|
| **View past sessions offline** | Requires full local database mirroring |
| **Edit synced sessions offline** | Requires conflict resolution |
| **Background sync** | Nice-to-have, not critical for MVP |

### Key Simplification: No Conflicts Possible

Because we're only supporting **create** operations offline (not updates to existing data), there are no sync conflicts to resolve. A new session created offline has never existed on the server, so pushing it is always safe.

---

## Current State Analysis

### Architecture Summary

The iOS app follows a **stateless, API-first design**:

```
SwiftUI Views → ViewModels (@Published) → Services → APIClient (Alamofire) → Backend API
```

**Key Characteristics:**
- Zero local persistence for operational data
- All data lives in memory via `@Published` ViewModel properties
- Every action requires an immediate API call
- App restart = complete data loss (must re-fetch)

### What We Can Leverage

1. **NetworkMonitor** - Already exists, tracks `isOnline` state
2. **In-memory caching** - Rifles, ammo, locations are fetched and held in memory
3. **Existing models** - `CreateSessionRequest`, `CreateDopeEntryRequest`, etc. already exist
4. **ImageService** - Already handles image compression and upload

### Key Insight: Memory Cache for Reference Data

When a user opens the app online, they load their rifles, ammunition, and locations into memory. These stay in memory during the session. So when they go offline at the range:
- They already have their rifle list in memory
- They already have their ammo list in memory
- They already have their locations in memory

We just need to queue the **new session data** they create.

---

## Architecture Proposal

### High-Level Design (Simple Queue)

```
┌─────────────────────────────────────────────────────────────────────┐
│                           SwiftUI Views                              │
│  • Shows offline banner when disconnected                            │
│  • Shows pending sync count                                          │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                           ViewModels                                 │
│  • Check NetworkMonitor.isOnline                                     │
│  • If online: use existing services                                  │
│  • If offline: save to OfflineSessionQueue                           │
└─────────────────────────────────────────────────────────────────────┘
            │                                       │
            ▼ (online)                              ▼ (offline)
┌───────────────────────────┐       ┌───────────────────────────────────┐
│   Existing Services       │       │     OfflineSessionQueue           │
│   (No changes needed)     │       │  • Saves sessions as JSON files   │
│                           │       │  • Saves images to local storage  │
└───────────────────────────┘       └───────────────────────────────────┘
            │                                       │
            ▼                                       │
┌───────────────────────────┐                       │
│       APIClient           │◄──────────────────────┘
│   (No changes needed)     │       (sync when online)
└───────────────────────────┘
```

### Storage Strategy: JSON Files (Simple & Debuggable)

Instead of SwiftData/CoreData, use simple JSON file storage:

```
Documents/
└── OfflineQueue/
    ├── sessions/
    │   ├── {uuid1}.json      # Complete session with all nested data
    │   ├── {uuid2}.json
    │   └── ...
    ├── images/
    │   ├── {uuid1}_group_1_original.jpg
    │   ├── {uuid1}_group_1_annotated.jpg
    │   └── ...
    └── cache/                 # Reference data cache
        ├── rifles.json        # All user's rifles
        ├── ammunition.json    # All user's ammunition + lots
        └── locations.json     # All user's saved locations
```

**Why files instead of a database?**
- Much simpler implementation
- No schema migrations needed
- Easy to debug (can inspect JSON files directly)
- Sufficient for queue-only use case
- Can upgrade to SwiftData later if we expand scope

### Reference Data Caching

To support offline cold-start (app completely closed, reopened without signal):

```
┌─────────────────────────────────────────────────────────────────────┐
│                         App Launch                                   │
└─────────────────────────────────────────────────────────────────────┘
                                │
                    ┌───────────┴───────────┐
                    ▼                       ▼
              Online?                   Offline?
                │                           │
                ▼                           ▼
    ┌───────────────────────┐   ┌───────────────────────────┐
    │ Fetch from API        │   │ Load from cache files     │
    │ Save copy to cache    │   │ Show "Using cached data"  │
    │ Display fresh data    │   │ Display cached data       │
    └───────────────────────┘   └───────────────────────────┘
```

**What gets cached:**
- Rifles (all fields needed to display in picker)
- Ammunition (all fields + lots)
- Saved Locations (name, coordinates)

**When cache is updated:**
- Every time data is successfully fetched from API
- On pull-to-refresh
- On app foreground (if online)

**Cache is NOT used for:**
- Historical sessions (still requires network to browse)
- Analytics data
- User profile (already cached in UserDefaults)

---

## Data Models

### PendingSession (New)

A complete session awaiting sync, stored as JSON:

```swift
struct PendingSession: Codable, Identifiable {
    let id: UUID                      // Local identifier
    let createdAt: Date               // When created offline
    var syncAttempts: Int = 0         // Retry counter
    var lastSyncError: String?        // Last error message

    // Session data (mirrors CreateSessionRequest)
    var sessionDate: Date
    var rifleSetupId: Int             // Reference to server ID (from memory cache)
    var locationId: Int?              // Optional location reference
    var notes: String?

    // Weather (captured at creation time from device/manual entry)
    var temperature: Double?
    var humidity: Double?
    var pressure: Double?
    var windSpeed: Double?
    var windDirection: Double?
    var altitude: Double?

    // Nested data (all the entries added during the session)
    var dopeEntries: [PendingDopeEntry]
    var chronoSessions: [PendingChronoSession]
    var groupEntries: [PendingGroupEntry]
}

struct PendingDopeEntry: Codable, Identifiable {
    let id: UUID
    var distance: Int
    var elevationMoa: Double?
    var elevationMil: Double?
    var windageMoa: Double?
    var windageMil: Double?
    var ammunitionId: Int?
    var notes: String?
}

struct PendingChronoSession: Codable, Identifiable {
    let id: UUID
    var ammunitionId: Int?
    var ammoLotId: Int?
    var chronographModel: String?
    var distanceToChronograph: Int?
    var notes: String?
    var velocityReadings: [PendingVelocityReading]
}

struct PendingVelocityReading: Codable, Identifiable {
    let id: UUID
    var shotNumber: Int
    var velocity: Int
    var isExcluded: Bool
}

struct PendingGroupEntry: Codable, Identifiable {
    let id: UUID
    var groupNumber: Int
    var distance: Int
    var numberOfShots: Int
    var groupSizeMoa: Double?
    var meanRadiusMoa: Double?
    var ammunitionId: Int?
    var notes: String?

    // Image file names (stored in images/ directory)
    var imageFileNames: [String]

    // Optional measurement data
    var measurement: PendingGroupMeasurement?
}

struct PendingGroupMeasurement: Codable {
    var holePositions: [HolePosition]
    var bulletDiameter: Double
    var calibrationMethod: String
    var measurementConfidence: Double?

    // Computed metrics (calculated locally)
    var horizontalSpread: Double?
    var verticalSpread: Double?
    var cep50: Double?

    // Image file names
    var originalImageFileName: String?
    var annotatedImageFileName: String?
}

struct HolePosition: Codable {
    var x: Double  // inches from POA
    var y: Double  // inches from POA
}
```

### OfflineSessionQueue (New Service)

```swift
@MainActor
final class OfflineSessionQueue: ObservableObject {
    static let shared = OfflineSessionQueue()

    @Published var pendingSessions: [PendingSession] = []
    @Published var isSyncing: Bool = false
    @Published var lastSyncError: String?

    private let fileManager = FileManager.default
    private let sessionsDirectory: URL
    private let imagesDirectory: URL

    var pendingCount: Int { pendingSessions.count }
    var hasPendingSessions: Bool { !pendingSessions.isEmpty }

    init() {
        let documents = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
        sessionsDirectory = documents.appendingPathComponent("OfflineQueue/sessions")
        imagesDirectory = documents.appendingPathComponent("OfflineQueue/images")

        // Create directories if needed
        try? fileManager.createDirectory(at: sessionsDirectory, withIntermediateDirectories: true)
        try? fileManager.createDirectory(at: imagesDirectory, withIntermediateDirectories: true)

        // Load existing pending sessions
        loadPendingSessions()
    }

    // MARK: - Queue Operations

    func queueSession(_ session: PendingSession) throws {
        // Save to file
        let fileURL = sessionsDirectory.appendingPathComponent("\(session.id).json")
        let data = try JSONEncoder().encode(session)
        try data.write(to: fileURL)

        // Update in-memory list
        pendingSessions.append(session)
    }

    func queueImage(_ image: UIImage, fileName: String) throws {
        let fileURL = imagesDirectory.appendingPathComponent(fileName)
        guard let data = image.jpegData(compressionQuality: 0.8) else {
            throw OfflineQueueError.imageCompressionFailed
        }
        try data.write(to: fileURL)
    }

    func updateSession(_ session: PendingSession) throws {
        // Update file
        let fileURL = sessionsDirectory.appendingPathComponent("\(session.id).json")
        let data = try JSONEncoder().encode(session)
        try data.write(to: fileURL)

        // Update in-memory list
        if let index = pendingSessions.firstIndex(where: { $0.id == session.id }) {
            pendingSessions[index] = session
        }
    }

    // MARK: - Sync Operations

    func syncAllPending() async {
        guard !isSyncing else { return }
        guard NetworkMonitor.shared.isConnected else { return }

        isSyncing = true
        lastSyncError = nil

        for session in pendingSessions {
            do {
                try await syncSession(session)
                // Remove from queue on success
                removeSession(session)
            } catch {
                // Mark error but continue with other sessions
                var updatedSession = session
                updatedSession.syncAttempts += 1
                updatedSession.lastSyncError = error.localizedDescription
                try? updateSession(updatedSession)
            }
        }

        isSyncing = false
    }

    private func syncSession(_ session: PendingSession) async throws {
        // Step 1: Create session on server
        let createRequest = CreateSessionRequest(
            sessionDate: session.sessionDate,
            rifleSetupId: session.rifleSetupId,
            locationId: session.locationId,
            notes: session.notes,
            temperature: session.temperature,
            // ... other weather fields
        )

        let createdSession = try await SessionService.shared.createSession(createRequest)
        let sessionId = createdSession.id

        // Step 2: Add DOPE entries
        for dope in session.dopeEntries {
            let dopeRequest = CreateDopeEntryRequest(
                distance: dope.distance,
                elevationMoa: dope.elevationMoa,
                // ... other fields
            )
            try await SessionService.shared.addDopeEntry(sessionId: sessionId, dopeRequest)
        }

        // Step 3: Add chrono sessions with velocity readings
        for chrono in session.chronoSessions {
            let chronoRequest = CreateChronoSessionRequest(
                ammunitionId: chrono.ammunitionId,
                // ... other fields
            )
            let createdChrono = try await SessionService.shared.addChronoSession(sessionId: sessionId, chronoRequest)

            // Add velocity readings
            for reading in chrono.velocityReadings {
                try await SessionService.shared.addVelocityReading(
                    sessionId: sessionId,
                    chronoSessionId: createdChrono.id,
                    velocity: reading.velocity
                )
            }
        }

        // Step 4: Add group entries with images
        for group in session.groupEntries {
            let groupRequest = CreateGroupEntryRequest(
                groupNumber: group.groupNumber,
                distance: group.distance,
                numberOfShots: group.numberOfShots,
                // ... other fields
            )
            let createdGroup = try await SessionService.shared.addGroupEntry(sessionId: sessionId, groupRequest)

            // Upload images
            for fileName in group.imageFileNames {
                let imageURL = imagesDirectory.appendingPathComponent(fileName)
                if let imageData = try? Data(contentsOf: imageURL),
                   let image = UIImage(data: imageData) {
                    try await ImageService.shared.uploadGroupImage(groupId: createdGroup.id, image: image)
                    // Delete local file after successful upload
                    try? fileManager.removeItem(at: imageURL)
                }
            }

            // Add measurement if present
            if let measurement = group.measurement {
                // Upload measurement images and create measurement
                // ... similar pattern
            }
        }
    }

    private func removeSession(_ session: PendingSession) {
        // Remove file
        let fileURL = sessionsDirectory.appendingPathComponent("\(session.id).json")
        try? fileManager.removeItem(at: fileURL)

        // Remove from memory
        pendingSessions.removeAll { $0.id == session.id }
    }

    private func loadPendingSessions() {
        guard let files = try? fileManager.contentsOfDirectory(at: sessionsDirectory, includingPropertiesForKeys: nil) else {
            return
        }

        pendingSessions = files.compactMap { url -> PendingSession? in
            guard url.pathExtension == "json",
                  let data = try? Data(contentsOf: url),
                  let session = try? JSONDecoder().decode(PendingSession.self, from: data) else {
                return nil
            }
            return session
        }
    }
}

enum OfflineQueueError: Error {
    case imageCompressionFailed
    case sessionNotFound
}
```

### ReferenceDataCache (New Service)

Caches rifles, ammunition, and locations for offline cold-start:

```swift
@MainActor
final class ReferenceDataCache: ObservableObject {
    static let shared = ReferenceDataCache()

    private let fileManager = FileManager.default
    private let cacheDirectory: URL

    // Cache file URLs
    private var riflesURL: URL { cacheDirectory.appendingPathComponent("rifles.json") }
    private var ammunitionURL: URL { cacheDirectory.appendingPathComponent("ammunition.json") }
    private var locationsURL: URL { cacheDirectory.appendingPathComponent("locations.json") }

    init() {
        let documents = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
        cacheDirectory = documents.appendingPathComponent("OfflineQueue/cache")
        try? fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)
    }

    // MARK: - Save to Cache (called after successful API fetch)

    func cacheRifles(_ rifles: [RifleSetup]) {
        saveToCache(rifles, url: riflesURL)
    }

    func cacheAmmunition(_ ammunition: [Ammunition]) {
        saveToCache(ammunition, url: ammunitionURL)
    }

    func cacheLocations(_ locations: [SavedLocation]) {
        saveToCache(locations, url: locationsURL)
    }

    // MARK: - Load from Cache (called when offline)

    func loadCachedRifles() -> [RifleSetup]? {
        loadFromCache(url: riflesURL)
    }

    func loadCachedAmmunition() -> [Ammunition]? {
        loadFromCache(url: ammunitionURL)
    }

    func loadCachedLocations() -> [SavedLocation]? {
        loadFromCache(url: locationsURL)
    }

    // MARK: - Cache Status

    var hasCachedData: Bool {
        fileManager.fileExists(atPath: riflesURL.path) &&
        fileManager.fileExists(atPath: ammunitionURL.path)
    }

    var cacheDate: Date? {
        try? fileManager.attributesOfItem(atPath: riflesURL.path)[.modificationDate] as? Date
    }

    // MARK: - Private Helpers

    private func saveToCache<T: Encodable>(_ data: T, url: URL) {
        do {
            let encoded = try JSONEncoder().encode(data)
            try encoded.write(to: url)
        } catch {
            print("Failed to cache data: \(error)")
        }
    }

    private func loadFromCache<T: Decodable>(url: URL) -> T? {
        guard let data = try? Data(contentsOf: url),
              let decoded = try? JSONDecoder().decode(T.self, from: data) else {
            return nil
        }
        return decoded
    }

    // MARK: - Clear Cache (on logout)

    func clearCache() {
        try? fileManager.removeItem(at: riflesURL)
        try? fileManager.removeItem(at: ammunitionURL)
        try? fileManager.removeItem(at: locationsURL)
    }
}
```

### Integration with Existing Services

The existing services get a small modification to cache data after fetching:

```swift
// In RifleService (or RifleViewModel)

func loadRifles() async {
    if NetworkMonitor.shared.isConnected {
        // Online: fetch from API and cache
        do {
            let rifles = try await apiClient.getRifles()
            self.rifles = rifles
            ReferenceDataCache.shared.cacheRifles(rifles)  // NEW: Save to cache
        } catch {
            self.error = error.localizedDescription
        }
    } else {
        // Offline: load from cache
        if let cached = ReferenceDataCache.shared.loadCachedRifles() {
            self.rifles = cached
            self.isUsingCachedData = true  // NEW: Flag to show indicator
        } else {
            self.error = "No cached data available. Connect to internet to load rifles."
        }
    }
}
```

---

## UI/UX Changes

### 1. Offline Banner

When offline, show a prominent but non-intrusive banner:

```swift
struct OfflineBanner: View {
    @ObservedObject var networkMonitor = NetworkMonitor.shared
    @ObservedObject var offlineQueue = OfflineSessionQueue.shared

    var body: some View {
        if !networkMonitor.isConnected {
            HStack {
                Image(systemName: "wifi.slash")
                Text("Offline Mode")
                Spacer()
                if offlineQueue.pendingCount > 0 {
                    Text("\(offlineQueue.pendingCount) pending")
                        .font(.caption)
                }
            }
            .padding(.horizontal)
            .padding(.vertical, 8)
            .background(Color.orange.opacity(0.9))
            .foregroundColor(.white)
        }
    }
}
```

**Placement:** At the top of main content views (Sessions list, Session detail, etc.)

### 2. Pending Sessions Section

On the Sessions list, show pending sessions in a distinct section:

```swift
// In SessionsListView
if offlineQueue.hasPendingSessions {
    Section("Pending Sync") {
        ForEach(offlineQueue.pendingSessions) { session in
            PendingSessionRow(session: session)
        }
    }
    .listRowBackground(Color.orange.opacity(0.1))
}
```

### 3. Sync Status Indicator

Show sync progress when syncing:

```swift
struct SyncStatusView: View {
    @ObservedObject var offlineQueue = OfflineSessionQueue.shared

    var body: some View {
        if offlineQueue.isSyncing {
            HStack {
                ProgressView()
                    .scaleEffect(0.8)
                Text("Syncing...")
            }
            .padding(8)
            .background(Color.blue.opacity(0.1))
            .cornerRadius(8)
        }
    }
}
```

### 4. Modified Session Creation Flow

The session creation flow needs minimal changes:

```swift
// In SessionViewModel

func saveSession() async {
    if NetworkMonitor.shared.isConnected {
        // Existing online flow
        do {
            let session = try await sessionService.createSession(request)
            // Navigate to session detail
        } catch {
            self.error = error.localizedDescription
        }
    } else {
        // New offline flow
        do {
            let pendingSession = PendingSession(
                id: UUID(),
                createdAt: Date(),
                sessionDate: request.sessionDate,
                rifleSetupId: request.rifleSetupId,
                // ... map other fields
                dopeEntries: [],
                chronoSessions: [],
                groupEntries: []
            )
            try OfflineSessionQueue.shared.queueSession(pendingSession)

            // Show success message
            self.showOfflineSaveSuccess = true
        } catch {
            self.error = error.localizedDescription
        }
    }
}
```

### 5. User Messaging

When user creates a session offline, show a clear message:

```
✓ Session Saved Locally

Your session has been saved to your device. It will automatically
sync to the server when you're back online.

You can continue adding DOPE, chrono, and group data.

[View Session]  [Start New Session]
```

---

## Implementation Phases

### Phase 1: Core Infrastructure (4-5 days)

**Goal:** Create the offline queue system AND reference data caching

**Tasks:**
1. Create `PendingSession` and related models
2. Create `OfflineSessionQueue` service
3. Implement JSON file save/load for pending sessions
4. Implement image file save
5. Create `ReferenceDataCache` service
6. Modify `RifleService`/`RifleViewModel` to cache on fetch, load from cache when offline
7. Modify `AmmunitionService`/`AmmunitionViewModel` to cache on fetch, load from cache when offline
8. Modify `LocationService`/`LocationViewModel` to cache on fetch, load from cache when offline
9. Add `pendingCount` to `AppState` for badge display
10. Add `isUsingCachedData` flag for UI indicators
11. Clear cache on logout
12. Write unit tests for queue and cache operations

**Deliverable:**
- Can save sessions locally
- Reference data cached and available on cold-start offline

---

### Phase 2: Session Creation Integration (2-3 days)

**Goal:** Enable offline session creation

**Tasks:**
1. Modify `SessionViewModel` to check network and route to queue
2. Create `PendingSessionDetailView` for viewing/editing pending sessions
3. Add DOPE/chrono/group entry to pending sessions
4. Handle image capture for pending sessions
5. Test full offline session creation flow

**Deliverable:** Can create complete sessions offline

---

### Phase 3: Sync Implementation (2-3 days)

**Goal:** Sync pending sessions when online

**Tasks:**
1. Implement `syncSession()` method in `OfflineSessionQueue`
2. Add sync trigger on network connectivity change
3. Add sync trigger on app foreground
4. Handle sync errors and retry logic
5. Remove synced sessions from queue
6. Clean up uploaded images

**Deliverable:** Pending sessions sync automatically when online

---

### Phase 4: UI Polish (2 days)

**Goal:** Clear user communication about offline state

**Tasks:**
1. Create `OfflineBanner` component
2. Add "Pending Sync" section to sessions list
3. Add sync status indicator
4. Add manual "Sync Now" button in settings
5. Show success/error messages for sync operations
6. Test all flows in airplane mode

**Deliverable:** Polished offline experience

---

### Phase Summary

| Phase | Description | Effort |
|-------|-------------|--------|
| 1 | Core Infrastructure (Queue + Cache) | 4-5 days |
| 2 | Session Creation Integration | 2-3 days |
| 3 | Sync Implementation | 2-3 days |
| 4 | UI Polish | 2 days |
| **Total** | | **10-13 days** (~2-3 weeks)

---

## Risk Assessment

### Risk 1: Data Loss if App Deleted
**Severity:** Medium
**Probability:** Low

**Description:** If user deletes app before syncing, pending sessions are lost.

**Mitigations:**
- Show warning on app if pending sessions exist
- Consider iCloud backup of queue (future enhancement)
- Clear messaging that data is "pending sync"

---

### Risk 2: Stale Reference Data
**Severity:** Low
**Probability:** Low

**Description:** User selects rifle/ammo while online, but it gets deleted on server before sync.

**Mitigations:**
- Server should return clear error if referenced entity doesn't exist
- Show error message with option to edit pending session
- Rare edge case in practice (single-user app)

---

### Risk 3: Large Image Queue
**Severity:** Low
**Probability:** Low

**Description:** User captures many images offline, consumes significant storage.

**Mitigations:**
- Compress images before saving (already doing 0.8 JPEG quality)
- Show storage warning if queue exceeds threshold
- Can add cleanup option in settings

---

### Risk 4: Sync Failures
**Severity:** Medium
**Probability:** Low

**Description:** Network issues during sync could leave session partially synced.

**Mitigations:**
- Atomic approach: don't remove from queue until fully synced
- Track which parts have been synced (for retry)
- Manual retry option available

---

## Future Enhancements

If the MVP proves successful, consider these additions:

### Phase 2: View Cached Sessions Offline
- Cache recently viewed sessions locally
- Show cached data when offline
- Mark as "may be outdated"

### Phase 3: Edit Synced Sessions Offline
- Queue updates to existing sessions
- Implement timestamp-based conflict resolution
- More complex but enables full offline experience

### Phase 4: Background Sync
- Use `BGTaskScheduler` for background sync
- Sync when on WiFi to save cellular data

### Phase 5: iCloud Backup
- Back up pending queue to iCloud
- Survive app reinstall

---

## Backend Changes Required

**None required for MVP!**

The existing API endpoints work as-is. The sync process simply calls the same endpoints the app would call if online:
- `POST /api/sessions` - Create session
- `POST /api/sessions/{id}/dope` - Add DOPE
- `POST /api/sessions/{id}/chrono` - Add chrono
- `POST /api/sessions/{id}/groups` - Add group
- `POST /api/groups/{id}/images` - Upload image

No new endpoints, no schema changes, no server modifications.

---

## Summary: Why This Approach Works

1. **Simple** - JSON files, no database, no complex sync logic
2. **Low Risk** - Create-only means no conflicts
3. **Minimal Changes** - Small modifications to existing services for caching
4. **Cold-Start Ready** - Reference data cached to disk, survives app close
5. **No Backend Changes** - Uses existing API endpoints
6. **Fast to Implement** - 2-3 weeks vs 4-6 weeks for full offline
7. **Solves the Real Problem** - Recording at the range without signal

## Complete Offline Scenario

```
1. User opens app at home (online)
   → Rifles, ammo, locations fetched from API
   → Cached to phone storage

2. User closes app, drives to range (no signal)

3. User opens app at range (offline)
   → App loads rifles, ammo, locations from cache
   → Shows "Offline Mode" banner
   → User creates session, adds DOPE/chrono/groups
   → Session saved to pending queue

4. User closes app, drives home

5. User opens app at home (online)
   → Pending session syncs to server automatically
   → Cache refreshed with latest data
   → Done!
```

---

## Document History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2026-01-01 | 1.0 | Claude | Initial full offline-first specification |
| 2026-01-01 | 2.0 | Claude | Simplified to create-only queue approach |

---

## Next Steps

1. **Review this specification** and confirm the approach
2. **Clarify any questions** about the design
3. **Begin Phase 1** implementation

Ready to proceed when you are!
