# Online Session Goes Offline Mid-Use

**Created:** 2026-01-04
**Status:** Implemented & Tested
**Completed:** 2026-01-04
**Priority:** 6 (from UnifiedGroupMeasurementTool.md)
**Related:** [20250103.UnifiedGroupMeasurementTool.md](./20250103.UnifiedGroupMeasurementTool.md)

## Problem Statement

When a user starts a session **online** (created on the server with a real `sessionId`), then loses connectivity mid-session while trying to add DOPE, groups, or chrono entries, the app currently:

1. Attempts the API request
2. Waits for timeout (or detects network failure)
3. Shows an error and fails the operation
4. User loses their entered data

**Real-world scenario:** User is at a shooting range with spotty cellular coverage. They create a session while they have signal, start shooting, then try to log DOPE data when signal drops. Their data entry fails and they have to re-enter it when signal returns.

## Solution Overview

Implement a **"graceful degradation"** pattern where:

1. **Detect** connectivity loss during save operations
2. **Queue** the operation for later sync instead of failing
3. **Continue** seamlessly - user keeps working
4. **Auto-sync** queued operations when connectivity returns
5. **Indicate** pending status with subtle visual feedback

### Key Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Scope | New entries only | Edit/delete of existing server data stays online-only to avoid complex conflict resolution |
| Sync behavior | Auto-sync on reconnect | Seamless UX, user doesn't need to think about it |
| User feedback | Toast + continue | Brief notification, doesn't interrupt workflow |
| Entry status | Subtle indicator | Small cloud icon on pending entries |

---

## Architecture

### New Component: `PendingEntryQueue`

A new service specifically for queuing individual entries (DOPE, groups, chrono) that belong to **already-synced sessions**.

This is distinct from `OfflineSessionQueue` which handles entire pending sessions.

```
┌─────────────────────────────────────────────────────────────────┐
│                     Entry Creation Flow                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   User adds DOPE/Group/Chrono to online session                 │
│                          │                                       │
│                          ▼                                       │
│              ┌───────────────────────┐                          │
│              │  Check connectivity   │                          │
│              │  (NetworkMonitor)     │                          │
│              └───────────┬───────────┘                          │
│                          │                                       │
│           ┌──────────────┴──────────────┐                       │
│           │                             │                        │
│           ▼                             ▼                        │
│   ┌───────────────┐            ┌───────────────┐                │
│   │    Online     │            │    Offline    │                │
│   │               │            │               │                │
│   │  POST to API  │            │  Queue entry  │                │
│   │               │            │  locally      │                │
│   └───────┬───────┘            └───────┬───────┘                │
│           │                             │                        │
│           ▼                             ▼                        │
│   ┌───────────────┐            ┌───────────────┐                │
│   │   Success     │            │ Show toast:   │                │
│   │   Refresh UI  │            │ "Saved        │                │
│   │               │            │  offline"     │                │
│   └───────────────┘            └───────────────┘                │
│                                         │                        │
│                                         ▼                        │
│                                ┌───────────────┐                │
│                                │ Mark entry    │                │
│                                │ with pending  │                │
│                                │ indicator     │                │
│                                └───────────────┘                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

             Auto-Sync on Reconnect
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│   NetworkMonitor detects: isConnected = true                    │
│                          │                                       │
│                          ▼                                       │
│              ┌───────────────────────┐                          │
│              │  PendingEntryQueue    │                          │
│              │  .syncAllPending()    │                          │
│              └───────────┬───────────┘                          │
│                          │                                       │
│                          ▼                                       │
│   For each pending entry (oldest first):                        │
│   ┌─────────────────────────────────────────┐                   │
│   │ 1. POST to API                          │                   │
│   │ 2. On success: Remove from queue        │                   │
│   │ 3. On failure: Increment retry count    │                   │
│   │ 4. Post notification for UI update      │                   │
│   └─────────────────────────────────────────┘                   │
│                          │                                       │
│                          ▼                                       │
│              ┌───────────────────────┐                          │
│              │  Show toast:          │                          │
│              │  "X entries synced"   │                          │
│              └───────────────────────┘                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Data Model: `PendingEntry`

```swift
/// Represents a single entry (DOPE, Group, Chrono) waiting to be synced
struct PendingEntry: Codable, Identifiable {
    let id: UUID
    let sessionId: Int          // The server session ID this belongs to
    let entryType: EntryType
    let payload: EntryPayload   // The data to send
    let createdAt: Date
    var syncAttempts: Int = 0
    var lastAttempt: Date?
    var lastError: String?

    enum EntryType: String, Codable {
        case dope
        case group
        case chrono
        case groupMeasurement   // For Quick Measure on existing groups
    }

    enum EntryPayload: Codable {
        case dope(DopeEntryRequest)
        case group(GroupEntryRequest)
        case chrono(ChronoSessionRequest)
        case groupMeasurement(groupId: Int, measurement: GroupMeasurementRequest)
    }
}
```

### Service: `PendingEntryQueue`

```swift
@MainActor
class PendingEntryQueue: ObservableObject {
    static let shared = PendingEntryQueue()

    // MARK: - Published State
    @Published private(set) var pendingEntries: [PendingEntry] = []
    @Published private(set) var isSyncing: Bool = false

    // MARK: - Storage
    private let storageURL: URL  // Documents/PendingEntries/

    // MARK: - Queue Operations
    func queueEntry(_ entry: PendingEntry)
    func removeEntry(id: UUID)
    func getEntriesForSession(_ sessionId: Int) -> [PendingEntry]

    // MARK: - Sync Operations
    func syncAllPending() async -> SyncResult
    func syncEntry(id: UUID) async throws

    // MARK: - Persistence
    private func save()
    private func load()
}
```

---

## Implementation Details

### 1. Modify ViewModels to Support Offline Queueing

#### SessionDetailViewModel Changes

Currently, adding entries calls the API directly and fails if offline. We need to:

1. Check connectivity before API call
2. If offline, queue the entry and show success with "pending" indicator
3. Refresh UI to show the entry with pending badge

```swift
// Current flow (fails when offline):
func addDopeEntry(_ request: DopeEntryRequest) async {
    do {
        let entry = try await sessionService.addDopeEntry(sessionId: session.id, request: request)
        // Success - add to local list
    } catch {
        // Shows error to user, data lost
    }
}

// New flow (graceful offline handling):
func addDopeEntry(_ request: DopeEntryRequest) async {
    // Try online first
    if NetworkMonitor.shared.isConnected {
        do {
            let entry = try await sessionService.addDopeEntry(sessionId: session.id, request: request)
            await loadSession() // Refresh from server
            return
        } catch let error as APIError where error.isRetryable {
            // Network failed during request - fall through to queue
        } catch {
            // Non-retryable error (validation, etc) - show error
            self.error = error
            return
        }
    }

    // Offline or network failed - queue for later
    let pendingEntry = PendingEntry(
        id: UUID(),
        sessionId: session.id,
        entryType: .dope,
        payload: .dope(request),
        createdAt: Date()
    )
    PendingEntryQueue.shared.queueEntry(pendingEntry)

    // Add temporary local entry for immediate UI feedback
    addLocalPendingEntry(pendingEntry)

    // Show toast
    ToastManager.shared.show("Saved offline - will sync when connected", icon: "cloud.fill")
}
```

### 2. Temporary Local Entry Display

When an entry is queued offline, we need to show it in the UI immediately. Two approaches:

**Option A: Optimistic UI Update**
- Create a local representation of the entry
- Display it in the list with pending indicator
- Replace with server version when synced

**Option B: Merged Display**
- Session detail shows both server entries AND pending entries
- Pending entries displayed inline with badge
- Removed from pending list when synced

**Recommended: Option B** - Simpler to implement, clearer to user.

```swift
// In SessionDetailView
var allDopeEntries: [DopeEntryDisplayItem] {
    // Server entries
    let serverEntries = session.dopeEntries.map {
        DopeEntryDisplayItem(entry: $0, isPending: false)
    }

    // Pending entries for this session
    let pendingEntries = PendingEntryQueue.shared
        .getEntriesForSession(session.id)
        .filter { $0.entryType == .dope }
        .map { DopeEntryDisplayItem(pendingEntry: $0) }

    // Merge and sort by date
    return (serverEntries + pendingEntries).sorted { $0.date > $1.date }
}
```

### 3. Pending Entry Indicator

Subtle cloud icon on entries that are pending sync:

```swift
struct PendingBadge: View {
    var body: some View {
        Image(systemName: "icloud.and.arrow.up")
            .font(.caption2)
            .foregroundColor(.secondary)
    }
}

// Usage in entry row:
HStack {
    // Entry content...

    Spacer()

    if entry.isPending {
        PendingBadge()
    }
}
```

### 4. Auto-Sync on Reconnect

Enhance `AppState` to trigger entry sync when connection returns:

```swift
// In AppState
private func setupConnectivityObserver() {
    // Existing observer...

    // Add entry sync trigger
    Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
        Task { @MainActor in
            if NetworkMonitor.shared.isConnected &&
               !PendingEntryQueue.shared.pendingEntries.isEmpty &&
               !PendingEntryQueue.shared.isSyncing {
                await self?.syncPendingEntries()
            }
        }
    }
}

private func syncPendingEntries() async {
    let result = await PendingEntryQueue.shared.syncAllPending()

    if result.successCount > 0 {
        ToastManager.shared.show(
            "\(result.successCount) \(result.successCount == 1 ? "entry" : "entries") synced",
            icon: "checkmark.icloud"
        )

        // Post notification so session detail refreshes
        NotificationCenter.default.post(name: .pendingEntriesSynced, object: nil)
    }
}
```

### 5. Toast Manager

Simple toast notification system for non-intrusive feedback:

```swift
@MainActor
class ToastManager: ObservableObject {
    static let shared = ToastManager()

    @Published var currentToast: Toast?

    struct Toast: Identifiable {
        let id = UUID()
        let message: String
        let icon: String?
        let duration: TimeInterval
    }

    func show(_ message: String, icon: String? = nil, duration: TimeInterval = 3.0) {
        currentToast = Toast(message: message, icon: icon, duration: duration)

        Task {
            try? await Task.sleep(for: .seconds(duration))
            if currentToast?.id == currentToast?.id {
                currentToast = nil
            }
        }
    }
}

// Toast overlay view
struct ToastOverlay: View {
    @ObservedObject var manager = ToastManager.shared

    var body: some View {
        VStack {
            Spacer()

            if let toast = manager.currentToast {
                HStack(spacing: 8) {
                    if let icon = toast.icon {
                        Image(systemName: icon)
                    }
                    Text(toast.message)
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 12)
                .background(.ultraThinMaterial)
                .clipShape(Capsule())
                .transition(.move(edge: .bottom).combined(with: .opacity))
                .padding(.bottom, 100) // Above tab bar
            }
        }
        .animation(.spring(duration: 0.3), value: manager.currentToast?.id)
    }
}
```

### 6. Handle Quick Measure Going Offline

The `QuickMeasureGroupViewModel` already has connectivity handling for initial saves. We need to extend it:

```swift
// In QuickMeasureGroupViewModel.calculateAndSave()

// Current: checks connectivity at start
// Enhanced: catch network errors during save and queue

func calculateAndSave() async {
    // ... existing calculation code ...

    do {
        if NetworkMonitor.shared.isConnected {
            try await saveToServer()
        } else {
            queueMeasurementForSync()
        }
    } catch let error as APIError where error.isRetryable {
        // Network failed mid-request - queue instead
        queueMeasurementForSync()
        savedOffline = true
    } catch {
        self.error = error.localizedDescription
    }
}

private func queueMeasurementForSync() {
    let request = GroupMeasurementRequest(/* ... */)
    let pendingEntry = PendingEntry(
        id: UUID(),
        sessionId: sessionId,
        entryType: .groupMeasurement,
        payload: .groupMeasurement(groupId: groupId, measurement: request),
        createdAt: Date()
    )
    PendingEntryQueue.shared.queueEntry(pendingEntry)

    // Save images locally
    saveImagesToLocalCache()

    ToastManager.shared.show("Measurement saved offline", icon: "cloud.fill")
}
```

---

## File Changes

### New Files

| File | Purpose |
|------|---------|
| `Core/Services/PendingEntryQueue.swift` | Queue management for individual entries |
| `Core/Models/PendingEntry.swift` | Data model for pending entries |
| `Core/UI/ToastManager.swift` | Toast notification manager |
| `Core/UI/ToastOverlay.swift` | Toast display view |
| `Core/UI/PendingBadge.swift` | Pending sync indicator badge |

### Modified Files

| File | Changes |
|------|---------|
| `SessionDetailViewModel.swift` | Add offline queueing for DOPE/group/chrono creation |
| `SessionDetailView.swift` | Merge pending entries into display, add pending badges |
| `QuickMeasureGroupViewModel.swift` | Queue measurement if network fails mid-save |
| `AppState.swift` | Add auto-sync trigger for pending entries |
| `TrueDope_iOSApp.swift` | Add ToastOverlay to root view |
| `DopeEntryRow.swift` | Add pending badge support |
| `GroupEntryRow.swift` | Add pending badge support |
| `ChronoSessionRow.swift` | Add pending badge support |

---

## User Experience Flow

### Scenario: Adding DOPE While Offline

1. User is viewing an online session (session exists on server)
2. User taps "Add DOPE"
3. User fills in the form, taps "Save"
4. App detects no connectivity
5. **Toast appears:** "Saved offline - will sync when connected" (3 seconds)
6. User returns to session detail
7. New DOPE entry appears in list with small cloud icon (⬆️☁️)
8. User continues adding more data...
9. Signal returns
10. App auto-syncs in background
11. **Toast appears:** "2 entries synced" (3 seconds)
12. Cloud icons disappear from synced entries
13. If user refreshes session, server data matches local

### Scenario: Quick Measure Loses Connection Mid-Save

1. User completes Quick Measure wizard on online session
2. User taps "Save"
3. App starts uploading images, connection drops
4. API call fails with network error
5. App catches retryable error, queues entry locally
6. **Toast appears:** "Measurement saved offline"
7. User sees measurement in session with pending badge
8. Later, when connected, auto-sync uploads measurement + images

---

## Edge Cases

### What if the session was deleted on server?

When syncing a pending entry, if we get a 404 (session not found):
- Remove the pending entry from queue
- Show error toast: "Session no longer exists"
- Entry is lost (acceptable - rare edge case)

### What if server validation fails?

If sync returns 400 (validation error):
- Mark entry as "failed" (not just pending)
- Show different indicator (warning icon)
- User can tap to see error and retry or delete

### What about duplicate entries?

If user adds same entry twice (once queued, once when online):
- Server should handle idempotency (or we accept duplicates)
- For MVP: Accept potential duplicates, user can delete extras

### Queue persistence across app restarts?

- `PendingEntryQueue` saves to disk on every change
- Loads from disk on init
- Entries persist until synced or manually deleted

---

## Testing Checklist

### Unit Tests

- [ ] `PendingEntryQueue` correctly persists entries to disk
- [ ] `PendingEntryQueue` correctly loads entries on init
- [ ] `PendingEntry` encodes/decodes all payload types correctly
- [ ] Sync removes entry on success
- [ ] Sync increments retry count on failure

### Integration Tests

- [ ] Adding DOPE while offline queues entry
- [ ] Adding group while offline queues entry
- [ ] Adding chrono while offline queues entry
- [ ] Quick Measure queues if network fails mid-save
- [ ] Auto-sync triggers when connectivity returns
- [ ] Session detail merges server + pending entries correctly
- [ ] Pending badge appears on queued entries
- [ ] Pending badge disappears after sync

### Manual Testing

- [ ] Enable airplane mode, add DOPE to existing session
- [ ] Toast appears "Saved offline"
- [ ] Entry shows in list with pending indicator
- [ ] Disable airplane mode
- [ ] Entry syncs automatically
- [ ] Toast shows sync success
- [ ] Indicator disappears
- [ ] Refresh session - data matches server

### Stress Testing

- [ ] Queue 10+ entries offline, verify all sync
- [ ] Toggle airplane mode rapidly during save
- [ ] Kill app with pending entries, relaunch, verify they sync

---

## Success Criteria

1. **No data loss:** User never loses entered data due to connectivity issues
2. **Seamless UX:** User can keep working without interruption when going offline
3. **Clear feedback:** User knows when data is pending vs synced (toast + badge)
4. **Reliable sync:** All queued entries eventually sync when connectivity returns
5. **Graceful failures:** Non-recoverable errors handled without crashing

---

## Implementation Order

1. **Create `PendingEntry` model** - Data structure for queued entries
2. **Create `PendingEntryQueue` service** - Queue management + persistence
3. **Create `ToastManager`** - User feedback system
4. **Modify `SessionDetailViewModel`** - Add offline queueing for add operations
5. **Create `PendingBadge`** - Visual indicator component
6. **Modify `SessionDetailView`** - Merge pending entries, show badges
7. **Modify `AppState`** - Add auto-sync trigger
8. **Update `QuickMeasureGroupViewModel`** - Handle network failure during save
9. **Add `ToastOverlay` to app root** - Display toasts app-wide
10. **Testing** - Full test pass per checklist above

---

## Implementation Summary (Completed 2026-01-04)

### Files Created

| File | Description |
|------|-------------|
| `Core/Models/PendingEntry.swift` | Data model for pending entries with payload enum, status tracking, and notification names |
| `Core/Services/PendingEntryQueue.swift` | Queue management with file persistence, sync logic, and image storage |
| `Core/UI/ToastManager.swift` | Toast notification manager with multiple styles (info, success, warning, error) |
| `Core/UI/PendingBadge.swift` | Visual components: `PendingBadge`, `PendingEntryStatusBadge`, `PendingEntryRow`, `PendingEntriesSection` |

### Files Modified

| File | Changes |
|------|---------|
| `Features/Sessions/SessionDetailView.swift` | Added offline queueing for `addDopeEntry`, `addChronoSession`, `addGroupEntry`; Added `PendingEntriesSection` to session content |
| `Features/Sessions/Components/DopeEntryForm.swift` | Fixed: Added `dismiss()` after save; Defaulted elevation/windage to "0" for better UX |
| `Features/GroupMeasurement/ViewModels/QuickMeasureGroupViewModel.swift` | Added `queueGroupMeasurementForLaterSync` and `queueMeasurementOnlyForLaterSync` methods for graceful offline handling |
| `App/AppState.swift` | Added `syncPendingEntriesOnReconnect()`, `startPendingEntrySyncTimer()` with 5-second polling |
| `App/TrueDope_iOSApp.swift` | Added `ToastOverlay()` to root view |

### Key Implementation Details

1. **Separate Queue from OfflineSessionQueue**: `PendingEntryQueue` handles individual entries for already-synced sessions, while `OfflineSessionQueue` handles entire pending sessions.

2. **Auto-Sync Strategy**:
   - Immediate sync attempt when network reconnects
   - Periodic 5-second polling when online with pending entries
   - Non-blocking - continues with remaining entries if one fails

3. **Toast Feedback**:
   - "Saved offline - will sync when connected" when queueing
   - "X entries synced" on successful sync
   - Styled variants for success/error states

4. **Form UX Fix**: DopeEntryForm now defaults elevation/windage to "0" so users only need to enter distance to save.

---

## Future Enhancements (Out of Scope)

- Edit/delete of server entries while offline (requires conflict resolution)
- Priority queue for sync order
- Exponential backoff for failed syncs
- Offline indicator in navigation bar
- Manual sync button for impatient users
- Detailed sync status view showing all pending items
