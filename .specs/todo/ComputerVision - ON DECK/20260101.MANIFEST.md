# Computer Vision Group Measurement - Implementation Specification

**Created:** January 1, 2026
**Status:** Planned
**Platform:** iOS (TrueDope-iOS)
**Difficulty:** Hard
**Effort Estimate:** 40-60 hours

---

## 1. Executive Summary

Add computer vision capabilities to the iOS group measurement feature using Apple's Vision framework. The system will:
1. **Auto-detect grid lines** on LaRue-style targets for automatic scale calibration
2. **Suggest bullet hole locations** for user confirmation/adjustment
3. Support multiple grid sizes (0.5" and 1.0")

**Approach:** Semi-automatic - CV assists, user confirms. Graceful fallback to manual when detection fails.

**Target Differentiation:** This feature would set TrueDope apart from competitors like Ballistic X by automating the tedious parts of group measurement while maintaining accuracy through user confirmation.

---

## 2. Supported Targets

### Primary Target: LaRue Tactical Grid Target
- Grid spacing: 0.5" (printed on target)
- Black grid lines on white paper
- High contrast, CV-friendly
- Already in use by the developer

### Secondary Target: Generic 1" Grid Targets
- Common in precision rifle community
- PRB targets, NSSF targets, etc.
- User-selectable grid size

### Future Consideration: QR/Fiducial Targets
- Custom TrueDope targets with encoded markers
- Would enable fully automatic measurement
- Out of scope for initial implementation

---

## 3. User Flow Changes

### 3.1 Modified Calibration Step

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      CALIBRATION                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚  â”‚     Manual       â”‚  Auto-Detect     â”‚  â† Segmented Control  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                                                                 â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
â”‚                                                                 â”‚
â”‚  IF MANUAL (existing flow):                                     â”‚
â”‚    â€¢ Tap two points to set reference distance                   â”‚
â”‚    â€¢ Enter distance in inches                                   â”‚
â”‚    â€¢ Continue                                                   â”‚
â”‚                                                                 â”‚
â”‚  IF AUTO-DETECT:                                                â”‚
â”‚    Grid Size:  [â— 0.5"]  [â—‹ 1.0"]                               â”‚
â”‚                                                                 â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚    â”‚      ðŸ” Detect Grid             â”‚                         â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                                                                 â”‚
â”‚    On Success:                                                  â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚    â”‚ âœ“ Grid Detected                 â”‚                         â”‚
â”‚    â”‚   Scale: 142.3 px/inch          â”‚                         â”‚
â”‚    â”‚   Confidence: 94%               â”‚                         â”‚
â”‚    â”‚                                 â”‚                         â”‚
â”‚    â”‚ [Continue]     [Re-detect]      â”‚                         â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                                                                 â”‚
â”‚    On Failure:                                                  â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚    â”‚ âœ— Grid Not Found                â”‚                         â”‚
â”‚    â”‚   Try better lighting or use    â”‚                         â”‚
â”‚    â”‚   manual calibration.           â”‚                         â”‚
â”‚    â”‚                                 â”‚                         â”‚
â”‚    â”‚ [Try Again]   [Use Manual]      â”‚                         â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Modified Hole Marking Step

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      MARK HOLES                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚  â”‚    ðŸ” Auto-Detect Holes         â”‚  â† NEW: Appears after     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    calibration complete   â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚           [Target Image with Overlays]                  â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚    â—â”€â”€â”€â— Green solid = Confirmed holes                  â”‚   â”‚
â”‚  â”‚    â—‹â”„â”„â—‹ Yellow dashed = CV suggestions                  â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚    Tap suggestion â†’ Confirm (turns green)               â”‚   â”‚
â”‚  â”‚    Long-press suggestion â†’ Reject (disappears)          â”‚   â”‚
â”‚  â”‚    Tap empty area â†’ Add manual hole                     â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Detected: 5 holes (3 confirmed, 2 pending)                     â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚  â”‚ Confirm All  â”‚  â”‚ Clear Suggestions â”‚                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚  â”‚         Set POA âŠ•               â”‚  (existing)               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚  â”‚         â†© Undo Last             â”‚  (existing)               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. Technical Architecture

### 4.1 New Files to Create

#### 4.1.1 Vision Service
**Path:** `TrueDope-iOS/TrueDope-iOS/Core/Services/VisionService.swift`

```swift
import Vision
import UIKit

// MARK: - Protocol

protocol VisionServiceProtocol {
    func detectGrid(in image: UIImage, gridSize: GridSize) async throws -> GridDetectionResult
    func detectHoles(in image: UIImage, pixelsPerInch: CGFloat, bulletDiameter: Decimal) async throws -> [SuggestedHole]
}

// MARK: - Implementation

final class VisionService: VisionServiceProtocol {

    static let shared = VisionService()

    // MARK: - Grid Detection

    func detectGrid(in image: UIImage, gridSize: GridSize) async throws -> GridDetectionResult {
        guard let cgImage = image.cgImage else {
            throw VisionError.invalidImage
        }

        // 1. Detect contours
        let contourRequest = VNDetectContoursRequest()
        contourRequest.contrastAdjustment = 2.0
        contourRequest.detectsDarkOnLight = true

        let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        try handler.perform([contourRequest])

        guard let observations = contourRequest.results else {
            throw VisionError.noContoursDetected
        }

        // 2. Extract line segments from contours
        let lines = extractGridLines(from: observations, imageSize: image.size)

        guard lines.count >= 6 else { // Need at least 3 horizontal + 3 vertical
            throw VisionError.insufficientGridLines
        }

        // 3. Calculate grid spacing
        guard let result = calculateGridSpacing(from: lines, gridSize: gridSize) else {
            throw VisionError.inconsistentSpacing
        }

        return result
    }

    // MARK: - Hole Detection

    func detectHoles(in image: UIImage, pixelsPerInch: CGFloat, bulletDiameter: Decimal) async throws -> [SuggestedHole] {
        guard let cgImage = image.cgImage else {
            throw VisionError.invalidImage
        }

        let expectedRadiusPixels = CGFloat(NSDecimalNumber(decimal: bulletDiameter / 2).doubleValue) * pixelsPerInch

        // Detect circular dark regions
        let contourRequest = VNDetectContoursRequest()
        contourRequest.contrastAdjustment = 1.5
        contourRequest.detectsDarkOnLight = true

        let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        try handler.perform([contourRequest])

        guard let observations = contourRequest.results else {
            return []
        }

        // Filter and score circular contours
        var candidates = extractHoleCandidates(
            from: observations,
            imageSize: image.size,
            expectedRadius: expectedRadiusPixels
        )

        // Non-maximum suppression
        candidates = nonMaxSuppression(candidates, overlapThreshold: 0.5)

        // Filter by confidence
        return candidates.filter { $0.confidence >= 0.5 }
    }

    // MARK: - Private Helpers

    private func extractGridLines(from observations: [VNContoursObservation], imageSize: CGSize) -> [DetectedGridLine] {
        // Implementation: Extract straight line segments, filter by orientation
        // Returns horizontal and vertical lines in image coordinates
    }

    private func calculateGridSpacing(from lines: [DetectedGridLine], gridSize: GridSize) -> GridDetectionResult? {
        // Implementation: Calculate median spacing, convert to px/inch
    }

    private func extractHoleCandidates(from observations: [VNContoursObservation], imageSize: CGSize, expectedRadius: CGFloat) -> [SuggestedHole] {
        // Implementation: Filter contours by circularity and size
    }

    private func nonMaxSuppression(_ holes: [SuggestedHole], overlapThreshold: CGFloat) -> [SuggestedHole] {
        // Implementation: Remove overlapping detections, keep highest confidence
    }
}
```

#### 4.1.2 Vision Detection Models
**Path:** `TrueDope-iOS/TrueDope-iOS/Models/VisionDetectionModels.swift`

```swift
import Foundation
import CoreGraphics

// MARK: - Grid Size

enum GridSize: String, CaseIterable, Identifiable {
    case halfInch = "0.5"
    case oneInch = "1.0"

    var id: String { rawValue }

    var inches: Double {
        switch self {
        case .halfInch: return 0.5
        case .oneInch: return 1.0
        }
    }

    var displayName: String {
        switch self {
        case .halfInch: return "0.5\""
        case .oneInch: return "1.0\""
        }
    }
}

// MARK: - Grid Detection Result

struct GridDetectionResult {
    let pixelsPerInch: CGFloat
    let confidence: Float  // 0.0-1.0
    let detectedLines: [DetectedGridLine]
    let gridSpacingPixels: CGFloat

    var confidencePercent: Int {
        Int(confidence * 100)
    }

    var formattedPixelsPerInch: String {
        String(format: "%.1f px/inch", pixelsPerInch)
    }
}

// MARK: - Detected Grid Line

struct DetectedGridLine: Identifiable {
    let id = UUID()
    let startPoint: CGPoint  // Image coordinates (pixels)
    let endPoint: CGPoint
    let orientation: LineOrientation

    var midpoint: CGPoint {
        CGPoint(
            x: (startPoint.x + endPoint.x) / 2,
            y: (startPoint.y + endPoint.y) / 2
        )
    }

    var length: CGFloat {
        hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y)
    }
}

enum LineOrientation {
    case horizontal
    case vertical
}

// MARK: - Suggested Hole

struct SuggestedHole: Identifiable {
    let id = UUID()
    let centerPixels: CGPoint  // Image coordinates
    let radiusPixels: CGFloat
    let confidence: Float  // 0.0-1.0
    var status: HoleSuggestionStatus = .suggested

    var confidencePercent: Int {
        Int(confidence * 100)
    }
}

enum HoleSuggestionStatus: Equatable {
    case suggested   // Yellow dashed circle, awaiting user action
    case confirmed   // User tapped - becomes standard green marker
    case rejected    // User long-pressed - hidden from view
}

// MARK: - Vision Errors

enum VisionError: LocalizedError {
    case invalidImage
    case noContoursDetected
    case insufficientGridLines
    case inconsistentSpacing
    case processingFailed(Error)

    var errorDescription: String? {
        switch self {
        case .invalidImage:
            return "Could not process the image"
        case .noContoursDetected:
            return "No patterns detected in image"
        case .insufficientGridLines:
            return "Grid pattern not found. Try better lighting or use manual calibration."
        case .inconsistentSpacing:
            return "Could not determine grid spacing. Lines may be obscured."
        case .processingFailed(let error):
            return "Processing failed: \(error.localizedDescription)"
        }
    }
}
```

#### 4.1.3 Suggested Hole Marker Component
**Path:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Components/SuggestedHoleMarker.swift`

```swift
import SwiftUI

struct SuggestedHoleMarker: View {
    let hole: SuggestedHole
    let displayScale: CGFloat  // For converting image coords to display coords
    let onConfirm: () -> Void
    let onReject: () -> Void

    @State private var isPressed = false

    private var displayRadius: CGFloat {
        max(hole.radiusPixels * displayScale, 12)  // Min 12pt for visibility
    }

    var body: some View {
        Circle()
            .stroke(
                Color.yellow,
                style: StrokeStyle(
                    lineWidth: 2,
                    lineCap: .round,
                    dash: [6, 4]  // Dashed pattern
                )
            )
            .frame(width: displayRadius * 2, height: displayRadius * 2)
            .opacity(hole.status == .suggested ? (isPressed ? 0.5 : 0.8) : 0)
            .overlay(
                // Confidence indicator (optional)
                Text("\(hole.confidencePercent)%")
                    .font(.system(size: 10, weight: .medium))
                    .foregroundColor(.yellow)
                    .offset(y: displayRadius + 12)
                    .opacity(hole.status == .suggested ? 0.7 : 0)
            )
            .position(
                x: hole.centerPixels.x * displayScale,
                y: hole.centerPixels.y * displayScale
            )
            .onTapGesture {
                onConfirm()
            }
            .onLongPressGesture(minimumDuration: 0.5) {
                onReject()
            } onPressingChanged: { pressing in
                withAnimation(.easeInOut(duration: 0.1)) {
                    isPressed = pressing
                }
            }
    }
}
```

#### 4.1.4 Grid Detection Overlay
**Path:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Components/GridDetectionOverlay.swift`

```swift
import SwiftUI

struct GridDetectionOverlay: View {
    let result: GridDetectionResult
    let imageSize: CGSize
    let displaySize: CGSize

    private var displayScale: CGFloat {
        displaySize.width / imageSize.width
    }

    var body: some View {
        Canvas { context, size in
            // Draw detected grid lines
            for line in result.detectedLines {
                let start = CGPoint(
                    x: line.startPoint.x * displayScale,
                    y: line.startPoint.y * displayScale
                )
                let end = CGPoint(
                    x: line.endPoint.x * displayScale,
                    y: line.endPoint.y * displayScale
                )

                var path = Path()
                path.move(to: start)
                path.addLine(to: end)

                context.stroke(
                    path,
                    with: .color(.blue.opacity(0.6)),
                    lineWidth: 2
                )
            }
        }
        .allowsHitTesting(false)
    }
}
```

### 4.2 Files to Modify

#### 4.2.1 QuickMeasureGroupViewModel.swift
**Path:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/ViewModels/QuickMeasureGroupViewModel.swift`

**Additions:**

```swift
// MARK: - Calibration Mode

enum CalibrationMode: String, CaseIterable {
    case manual
    case gridDetect

    var displayName: String {
        switch self {
        case .manual: return "Manual"
        case .gridDetect: return "Auto-Detect"
        }
    }
}

// Add to QuickMeasureGroupViewModel class:

// MARK: - Grid Detection State

@Published var calibrationMode: CalibrationMode = .manual
@Published var selectedGridSize: GridSize = .halfInch
@Published var gridDetectionResult: GridDetectionResult?
@Published var isDetectingGrid = false
@Published var gridDetectionError: String?

// MARK: - Hole Detection State

@Published var suggestedHoles: [SuggestedHole] = []
@Published var isDetectingHoles = false
@Published var holeDetectionError: String?

private let visionService: VisionServiceProtocol

// Update init to inject VisionService:
init(..., visionService: VisionServiceProtocol = VisionService.shared) {
    self.visionService = visionService
    // ... existing init
}

// MARK: - Grid Detection Methods

func detectGrid() async {
    guard let image = capturedImage else { return }

    isDetectingGrid = true
    gridDetectionError = nil
    gridDetectionResult = nil

    do {
        let result = try await visionService.detectGrid(in: image, gridSize: selectedGridSize)
        gridDetectionResult = result
        pixelsPerInch = result.pixelsPerInch
    } catch {
        gridDetectionError = error.localizedDescription
    }

    isDetectingGrid = false
}

func resetGridDetection() {
    gridDetectionResult = nil
    gridDetectionError = nil
    if calibrationMode == .gridDetect {
        pixelsPerInch = nil
    }
}

// MARK: - Hole Detection Methods

func detectHoles() async {
    guard let image = capturedImage,
          let ppi = pixelsPerInch else { return }

    isDetectingHoles = true
    holeDetectionError = nil
    suggestedHoles = []

    do {
        suggestedHoles = try await visionService.detectHoles(
            in: image,
            pixelsPerInch: ppi,
            bulletDiameter: bulletDiameter
        )
    } catch {
        holeDetectionError = error.localizedDescription
    }

    isDetectingHoles = false
}

func confirmSuggestedHole(_ hole: SuggestedHole) {
    guard let index = suggestedHoles.firstIndex(where: { $0.id == hole.id }) else { return }

    // Add to confirmed holes
    holeMarkersPixels.append(hole.centerPixels)

    // Update status
    suggestedHoles[index].status = .confirmed
}

func rejectSuggestedHole(_ hole: SuggestedHole) {
    guard let index = suggestedHoles.firstIndex(where: { $0.id == hole.id }) else { return }
    suggestedHoles[index].status = .rejected
}

func confirmAllSuggestedHoles() {
    for hole in suggestedHoles where hole.status == .suggested {
        holeMarkersPixels.append(hole.centerPixels)
    }
    suggestedHoles = suggestedHoles.map { hole in
        var updated = hole
        if hole.status == .suggested {
            updated.status = .confirmed
        }
        return updated
    }
}

func clearSuggestedHoles() {
    suggestedHoles = []
}

// MARK: - Update calculateAndSave

// In calculateAndSave(), update the calibration method:
let measurementRequest = CreateGroupMeasurementRequest(
    holePositions: holePositions,
    bulletDiameter: bulletDiameter,
    calibrationMethod: calibrationMode == .gridDetect ? .gridDetect : .manual,
    measurementConfidence: gridDetectionResult.map { Decimal(Double($0.confidence)) }
)
```

#### 4.2.2 QuickMeasureGroupFlow.swift
**Path:** `TrueDope-iOS/TrueDope-iOS/Features/GroupMeasurement/Views/QuickMeasureGroupFlow.swift`

**Modifications to QuickCaptureCalibrationStepView:**

```swift
// Add to the calibration step view:

@State private var selectedCalibrationMode: CalibrationMode = .manual

var body: some View {
    VStack(spacing: 20) {
        // Mode selector
        Picker("Calibration Mode", selection: $viewModel.calibrationMode) {
            ForEach(CalibrationMode.allCases, id: \.self) { mode in
                Text(mode.displayName).tag(mode)
            }
        }
        .pickerStyle(.segmented)
        .padding(.horizontal)

        if viewModel.calibrationMode == .manual {
            // Existing manual calibration UI
            manualCalibrationView
        } else {
            // New auto-detect UI
            autoDetectCalibrationView
        }
    }
}

@ViewBuilder
private var autoDetectCalibrationView: some View {
    VStack(spacing: 16) {
        // Grid size picker
        HStack {
            Text("Grid Size:")
            Picker("Grid Size", selection: $viewModel.selectedGridSize) {
                ForEach(GridSize.allCases) { size in
                    Text(size.displayName).tag(size)
                }
            }
            .pickerStyle(.segmented)
        }
        .padding(.horizontal)

        // Image preview with grid overlay
        ZStack {
            if let image = viewModel.capturedImage {
                Image(uiImage: image)
                    .resizable()
                    .aspectRatio(contentMode: .fit)

                if let result = viewModel.gridDetectionResult {
                    GridDetectionOverlay(
                        result: result,
                        imageSize: image.size,
                        displaySize: /* calculated display size */
                    )
                }
            }
        }
        .frame(maxHeight: 300)

        // Detection button / results
        if viewModel.isDetectingGrid {
            ProgressView("Detecting grid...")
        } else if let result = viewModel.gridDetectionResult {
            // Success state
            VStack(spacing: 8) {
                Label("Grid Detected", systemImage: "checkmark.circle.fill")
                    .foregroundColor(.green)
                Text(result.formattedPixelsPerInch)
                    .font(.headline)
                Text("Confidence: \(result.confidencePercent)%")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            HStack {
                Button("Re-detect") {
                    Task { await viewModel.detectGrid() }
                }
                .buttonStyle(.bordered)

                Button("Continue") {
                    viewModel.goToNextStep()
                }
                .buttonStyle(.borderedProminent)
            }
        } else if let error = viewModel.gridDetectionError {
            // Failure state
            VStack(spacing: 8) {
                Label("Detection Failed", systemImage: "xmark.circle.fill")
                    .foregroundColor(.red)
                Text(error)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
            }

            HStack {
                Button("Try Again") {
                    Task { await viewModel.detectGrid() }
                }
                .buttonStyle(.bordered)

                Button("Use Manual") {
                    viewModel.calibrationMode = .manual
                }
                .buttonStyle(.borderedProminent)
            }
        } else {
            // Initial state
            Button {
                Task { await viewModel.detectGrid() }
            } label: {
                Label("Detect Grid", systemImage: "viewfinder")
            }
            .buttonStyle(.borderedProminent)
        }
    }
}
```

**Modifications to QuickCaptureHoleMarkingView:**

```swift
// Add auto-detect button and suggested hole overlays:

var body: some View {
    VStack(spacing: 16) {
        // Auto-detect button (new)
        if !viewModel.isDetectingHoles && viewModel.suggestedHoles.isEmpty {
            Button {
                Task { await viewModel.detectHoles() }
            } label: {
                Label("Auto-Detect Holes", systemImage: "viewfinder")
            }
            .buttonStyle(.bordered)
        }

        if viewModel.isDetectingHoles {
            ProgressView("Detecting holes...")
        }

        // Image with overlays
        ZoomableImageView(image: viewModel.capturedImage) { tapPoint in
            if viewModel.isSettingPOA {
                viewModel.setPOA(at: tapPoint)
            } else {
                viewModel.addHole(at: tapPoint)
            }
        } content: { displayScale in
            // Existing confirmed hole markers
            ForEach(Array(viewModel.holeMarkersPixels.enumerated()), id: \.offset) { index, position in
                HoleMarker(
                    position: position,
                    index: index,
                    displayScale: displayScale,
                    isSelected: viewModel.selectedHoleIndex == index
                )
            }

            // NEW: Suggested hole markers
            ForEach(viewModel.suggestedHoles.filter { $0.status == .suggested }) { hole in
                SuggestedHoleMarker(
                    hole: hole,
                    displayScale: displayScale,
                    onConfirm: { viewModel.confirmSuggestedHole(hole) },
                    onReject: { viewModel.rejectSuggestedHole(hole) }
                )
            }

            // POA marker
            if let poa = viewModel.poaPositionPixels {
                POAMarker(position: poa, displayScale: displayScale)
            }
        }

        // Suggestion controls (new)
        if !viewModel.suggestedHoles.filter({ $0.status == .suggested }).isEmpty {
            HStack {
                Button("Confirm All") {
                    viewModel.confirmAllSuggestedHoles()
                }
                .buttonStyle(.borderedProminent)

                Button("Clear Suggestions") {
                    viewModel.clearSuggestedHoles()
                }
                .buttonStyle(.bordered)
            }
        }

        // Existing controls...
    }
}
```

---

## 5. Algorithm Details

### 5.1 Grid Line Detection

```
INPUT: UIImage of target
OUTPUT: [DetectedGridLine] - horizontal and vertical lines in image coordinates

ALGORITHM:
1. Convert UIImage â†’ CGImage
2. Create VNDetectContoursRequest with:
   - contrastAdjustment = 2.0 (enhance grid lines)
   - detectsDarkOnLight = true (black lines on white paper)
3. Perform request with VNImageRequestHandler
4. For each VNContoursObservation:
   a. Simplify contour path (tolerance 0.01)
   b. Walk path segments
   c. For each segment:
      - Calculate angle from horizontal
      - If within Â±5Â° of horizontal â†’ classify as horizontal
      - If within Â±5Â° of vertical â†’ classify as vertical
      - Discard diagonal segments
   d. Merge collinear segments within threshold
5. Filter lines by minimum length (10% of image width)
6. Return classified lines in image pixel coordinates

COORDINATE CONVERSION:
- Vision uses normalized (0-1) coordinates with Y origin at BOTTOM
- Image uses pixel coordinates with Y origin at TOP
- Convert: imageY = (1.0 - visionY) * imageHeight
```

### 5.2 Grid Spacing Calculation

```
INPUT: [DetectedGridLine], GridSize
OUTPUT: GridDetectionResult (or nil if invalid)

ALGORITHM:
1. Separate lines by orientation:
   - horizontalLines = lines.filter { $0.orientation == .horizontal }
   - verticalLines = lines.filter { $0.orientation == .vertical }

2. Validate minimum lines:
   - Need at least 3 horizontal AND 3 vertical lines
   - Otherwise return nil (insufficient data)

3. Sort by position:
   - Sort horizontal lines by Y coordinate (midpoint)
   - Sort vertical lines by X coordinate (midpoint)

4. Calculate adjacent spacings:
   - For horizontal: spacing[i] = lines[i+1].midY - lines[i].midY
   - For vertical: spacing[i] = lines[i+1].midX - lines[i].midX

5. Find median spacing (robust to outliers):
   - medianHSpacing = median(horizontalSpacings)
   - medianVSpacing = median(verticalSpacings)

6. Validate consistency:
   - Check that H and V spacings are within 10% of each other
   - If not, return nil (likely not a square grid)

7. Calculate pixels per inch:
   - avgSpacing = (medianHSpacing + medianVSpacing) / 2
   - pixelsPerInch = avgSpacing / gridSize.inches

8. Calculate confidence:
   - Based on spacing variance and line count
   - More lines + lower variance = higher confidence

CONFIDENCE CALCULATION:
confidence = min(
    lineCountFactor,    // More lines = better
    spacingConsistency  // Lower variance = better
) * 100%

Where:
- lineCountFactor = min(1.0, totalLines / 20)
- spacingConsistency = 1.0 - (stdDev(spacings) / mean(spacings))
```

### 5.3 Bullet Hole Detection

```
INPUT: UIImage, pixelsPerInch, bulletDiameter (inches)
OUTPUT: [SuggestedHole]

ALGORITHM:
1. Calculate expected hole size:
   - expectedRadius = (bulletDiameter / 2) * pixelsPerInch
   - minRadius = expectedRadius * 0.5 (torn paper makes holes larger)
   - maxRadius = expectedRadius * 1.5

2. Create VNDetectContoursRequest:
   - contrastAdjustment = 1.5
   - detectsDarkOnLight = true (dark holes on light paper)

3. For each contour observation:
   a. Get bounding box (normalized coordinates)
   b. Convert to image pixels
   c. Calculate dimensions:
      - width = boundingBox.width * imageWidth
      - height = boundingBox.height * imageHeight

   d. Check circularity (aspect ratio):
      - aspectRatio = width / height
      - If aspectRatio < 0.6 or > 1.4: skip (not circular)

   e. Calculate effective radius:
      - diameter = (width + height) / 2
      - radius = diameter / 2

   f. Check size match:
      - If radius < minRadius or > maxRadius: skip

   g. Calculate center in image coordinates:
      - centerX = boundingBox.midX * imageWidth
      - centerY = (1.0 - boundingBox.midY) * imageHeight  // Flip Y

   h. Score candidate:
      - circularity = 1.0 - abs(1.0 - aspectRatio)
      - sizeMatch = 1.0 - abs(radius - expectedRadius) / expectedRadius
      - confidence = (circularity + sizeMatch) / 2

   i. Add to candidates if confidence >= 0.4

4. Non-maximum suppression:
   - Sort candidates by confidence (descending)
   - For each candidate:
     - If overlaps with higher-confidence kept candidate: discard
     - Otherwise: keep
   - Overlap threshold = 50% of radius

5. Filter by minimum confidence (0.5) and return

NMS OVERLAP CALCULATION:
overlap(a, b) = distance(a.center, b.center) < (a.radius + b.radius) * 0.5
```

---

## 6. Error Handling & Fallbacks

| Scenario | Detection Method | User Message | Fallback Action |
|----------|-----------------|--------------|-----------------|
| Grid not found | <3 horizontal OR <3 vertical lines | "Grid pattern not found. Try better lighting or use manual calibration." | Show "Use Manual" button |
| Inconsistent grid | H/V spacing differ by >10% | "Could not determine grid spacing. Lines may be obscured." | Show "Use Manual" button |
| Low confidence | Confidence <60% | "Grid detected with low confidence (X%). Results may be inaccurate." | Allow proceed with warning |
| No holes found | Zero candidates after filtering | "No holes detected. Mark holes manually below." | Manual marking still available |
| Too many detections | >20 candidates | Only show top 10 by confidence | User confirms/rejects subset |
| Image processing failed | Vision framework error | "Could not process image. Try a clearer photo." | Offer retry or manual |

---

## 7. Testing Strategy

### 7.1 Unit Tests

**VisionServiceTests.swift:**
- `testGridDetection_withValidTarget_detectsLines()`
- `testGridDetection_withNoGrid_throwsError()`
- `testGridSpacing_withHalfInchGrid_calculatesCorrectPPI()`
- `testGridSpacing_withOneInchGrid_calculatesCorrectPPI()`
- `testHoleDetection_withVisibleHoles_returnsCandidates()`
- `testHoleDetection_withNoHoles_returnsEmpty()`
- `testNonMaxSuppression_removesOverlappingDetections()`
- `testCoordinateConversion_visionToImage_flipsY()`

### 7.2 Test Images Needed

| Image Type | Purpose | Conditions |
|------------|---------|------------|
| Clean LaRue target (unshot) | Baseline grid detection | Good lighting |
| LaRue target with 5-shot group | Standard use case | Indoor lighting |
| LaRue target with tight group | Overlapping hole detection | Various |
| LaRue target with large group | Wide spread detection | Various |
| Low light target photo | Edge case handling | Dim lighting |
| Angled target photo | Perspective handling | 10-15Â° angle |
| Partial grid visibility | Robustness testing | Grid partially cropped |

### 7.3 Integration Tests

- Full flow: capture â†’ auto-calibrate â†’ auto-detect holes â†’ confirm â†’ save
- Fallback flow: auto-detect fails â†’ switch to manual â†’ complete measurement
- Mixed flow: auto-calibrate â†’ manual hole marking

---

## 8. Implementation Phases

### Phase 1: Vision Service Foundation (Est. 15-20 hours)
- [ ] Create VisionDetectionModels.swift
- [ ] Create VisionService.swift with protocol
- [ ] Implement grid line detection algorithm
- [ ] Implement grid spacing calculation
- [ ] Add coordinate conversion utilities
- [ ] Write unit tests with test images

### Phase 2: Grid Detection UI (Est. 10-15 hours)
- [ ] Create GridDetectionOverlay.swift
- [ ] Add calibration mode state to ViewModel
- [ ] Modify calibration step with segmented control
- [ ] Add grid size picker
- [ ] Wire up detection with loading/error states
- [ ] Implement fallback to manual flow
- [ ] Test with real LaRue photos

### Phase 3: Hole Detection (Est. 10-15 hours)
- [ ] Implement hole detection in VisionService
- [ ] Create SuggestedHoleMarker.swift
- [ ] Add hole detection state to ViewModel
- [ ] Add "Auto-Detect Holes" button to hole marking step
- [ ] Implement confirm/reject gestures
- [ ] Implement "Confirm All" and "Clear" actions
- [ ] Test with various group sizes

### Phase 4: Integration & Polish (Est. 5-10 hours)
- [ ] End-to-end testing
- [ ] Tune detection parameters
- [ ] Handle edge cases
- [ ] Performance optimization
- [ ] User feedback refinement
- [ ] Update calibrationMethod in saved measurements

---

## 9. Future Enhancements

### 9.1 Custom TrueDope Targets (Future)
- Design targets with QR/fiducial markers for fully automatic calibration
- Encode target ID, scale, and orientation in markers
- Enable cloud-synced target recognition

### 9.2 ML-Enhanced Detection (Future)
- Train Core ML model on labeled hole images
- Improve accuracy for challenging conditions
- Edge detection for more precise hole centers

### 9.3 Multi-Target Support (Future)
- Detect multiple targets in single image
- Support target types beyond grid (bullseye, NRA, etc.)
- Community-contributed target profiles

---

## 10. Dependencies

### Frameworks Required
- **Vision** (Apple) - Built into iOS, no pod/package needed
- **CoreGraphics** - Already in use
- **UIKit** - Already in use

### No External Dependencies
This feature uses only Apple's built-in frameworks. No CocoaPods, SPM packages, or third-party libraries required.

---

## 11. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Grid detection unreliable | Medium | High | Graceful fallback to manual; tune parameters with real photos |
| Hole detection false positives | Medium | Medium | User confirmation required; confidence threshold filtering |
| Performance issues | Low | Medium | Background processing; image downscaling if needed |
| Vision API changes | Low | High | Abstract behind protocol; version-check if needed |
| User confusion with new UI | Medium | Low | Clear mode labels; helpful error messages; preserve manual option |

---

## Appendix A: File Tree

```
TrueDope-iOS/TrueDope-iOS/
â”œâ”€â”€ Core/
â”‚   â””â”€â”€ Services/
â”‚       â””â”€â”€ VisionService.swift                    [NEW]
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ GroupMeasurement.swift                     [EXISTING - reference]
â”‚   â””â”€â”€ VisionDetectionModels.swift                [NEW]
â””â”€â”€ Features/
    â””â”€â”€ GroupMeasurement/
        â”œâ”€â”€ Components/
        â”‚   â”œâ”€â”€ HoleMarker.swift                   [EXISTING]
        â”‚   â”œâ”€â”€ SuggestedHoleMarker.swift          [NEW]
        â”‚   â””â”€â”€ GridDetectionOverlay.swift         [NEW]
        â”œâ”€â”€ ViewModels/
        â”‚   â””â”€â”€ QuickMeasureGroupViewModel.swift   [MODIFY]
        â””â”€â”€ Views/
            â””â”€â”€ QuickMeasureGroupFlow.swift        [MODIFY]
```

---

## Appendix B: Related Documentation

- [20251230.BugsAndFeatures.md](../20251230.BugsAndFeatures.md) - Item #10 (original requirement)
- [Apple Vision Framework Documentation](https://developer.apple.com/documentation/vision)
- [VNDetectContoursRequest](https://developer.apple.com/documentation/vision/vndetectcontoursrequest)
